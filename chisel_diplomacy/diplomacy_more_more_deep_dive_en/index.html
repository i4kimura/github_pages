



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.0.2">
    
    
      
        <title>Hardware Description Language Chisel & Diplomacy <span style="color:red">Deeper</span> dive - FPGA開発日記 カテゴリ別記事インデックス</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.982221ab.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.224b79ff.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
      <script src="../../assets/javascripts/modernizr.1f0bcf2b.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#hardware-description-language-chisel-diplomacy-deeper-dive" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="FPGA開発日記 カテゴリ別記事インデックス" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              FPGA開発日記 カテゴリ別記事インデックス
            </span>
            <span class="md-header-nav__topic">
              Hardware Description Language Chisel & Diplomacy <span style="color:red">Deeper</span> dive
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="FPGA開発日記 カテゴリ別記事インデックス" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    FPGA開発日記 カテゴリ別記事インデックス
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../30os/" title="オペレーティングシステム" class="md-nav__link">
      オペレーティングシステム
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../cpu/" title="CPU" class="md-nav__link">
      CPU
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../dsl_ruby/" title="DSLでビルドツールを自作する" class="md-nav__link">
      DSLでビルドツールを自作する
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../gpgpu/" title="GPGPU 記事一覧" class="md-nav__link">
      GPGPU 記事一覧
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../isca_2019/" title="Isca 2019" class="md-nav__link">
      Isca 2019
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../llvm/" title="LLVM" class="md-nav__link">
      LLVM
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../lowrisc_llvm/" title="RISC-V LLVMバックエンドのステップバイステップガイド" class="md-nav__link">
      RISC-V LLVMバックエンドのステップバイステップガイド
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../machine_learning/" title="機械学習 / TensorFlow" class="md-nav__link">
      機械学習 / TensorFlow
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../mastering_bitcoin/" title="Bitcoin 記事一覧" class="md-nav__link">
      Bitcoin 記事一覧
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../qemu/" title="QEMU" class="md-nav__link">
      QEMU
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../quantum_computing/" title="量子コンピュータ / Q# 記事一覧" class="md-nav__link">
      量子コンピュータ / Q# 記事一覧
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../riscv/" title="RISC-V" class="md-nav__link">
      RISC-V
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../rust/" title="Rust" class="md-nav__link">
      Rust
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../vivado_hls/" title="Vivado-HLS" class="md-nav__link">
      Vivado-HLS
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../zero_deep_3/" title="ゼロから作るDeep Learning ③ のPython実装をRubyで作り直してみる" class="md-nav__link">
      ゼロから作るDeep Learning ③ のPython実装をRubyで作り直してみる
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-17" type="checkbox" id="nav-17" checked>
    
    <label class="md-nav__link" for="nav-17">
      Chisel diplomacy
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-17">
        Chisel diplomacy
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../chisel_basic/" title="Chisel basic" class="md-nav__link">
      Chisel basic
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../chisel_tilelink/" title="9. TileLinkとDiplomacyリファレンス" class="md-nav__link">
      9. TileLinkとDiplomacyリファレンス
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../diplomacy_more_more_deep_dive/" title="ハードウェア記述言語Chiselを<span style="color: red">もっともっと</span>活用するためのDiplomacy概説" class="md-nav__link">
      ハードウェア記述言語Chiselを<span style="color: red">もっともっと</span>活用するためのDiplomacy概説
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
    <a href="./" title="Hardware Description Language Chisel & Diplomacy <span style="color:red">Deeper</span> dive" class="md-nav__link md-nav__link--active">
      Hardware Description Language Chisel & Diplomacy <span style="color:red">Deeper</span> dive
    </a>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../memo/" title="Chisel v.s. Verilog" class="md-nav__link">
      Chisel v.s. Verilog
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-18" type="checkbox" id="nav-18">
    
    <label class="md-nav__link" for="nav-18">
      Cq
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-18">
        Cq
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../cq/hifive_unleashed/" title="【供養】 CQ出版インターフェース2019年オープンソースRISC-V特集時にボツとなったHiFive Unleashed特集原稿" class="md-nav__link">
      【供養】 CQ出版インターフェース2019年オープンソースRISC-V特集時にボツとなったHiFive Unleashed特集原稿
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="hardware-description-language-chisel-diplomacy-deeper-dive">Hardware Description Language Chisel &amp; Diplomacy <span style="color:red">Deeper</span> dive</h1>
<ul>
<li>Presenter：msyksphinz (Author of FPGA development diary)</li>
<li>@msyksphinz_dev</li>
<li>https://msyksphinz.hatenablog.com</li>
</ul>
<h1 id="about-presenter">About Presenter</h1>
<ul>
<li>Interesting Topic: Computer Architecture, Low-Layer Programming</li>
<li>X86 (Studying via implementation of QEMU with Rust)</li>
<li>MIPS (Studied through implementation Instruction Set Simulator)</li>
<li>ARM (Studying ...)</li>
<li><span style="color: red">RISC-V</span></li>
<li>My work : Hardware development</li>
<li>General Processor, Accelerator, and so on ...</li>
<li>HDL skill: Verilog, System Verilog (except UVM), Chisel</li>
<li>My first HDL I studied is VHDL (already I forget)</li>
<li>When I was a student, I implemented MIPS CPU by myself and run it on Spartan-3 FPGA.</li>
<li>
<p>Low Layer Programming</p>
</li>
<li>
<p>I started my work by analyzing and verifying the performance of general-purpose CPUs, so I can do some low-layer programming (I think).</p>
</li>
<li>I like QEMU and LLVM.</li>
<li>When I learn a new ISA, I start by building an instruction set simulator!</li>
<li>Other</li>
<li>Programming Languages: C++ / Ruby / Rust</li>
<li>I'm addicted to Rust lately... <span style="color:red">Hey, isn't it full of <code>unsafe</code> when you write low-layer stuff? :)</span>.</li>
<li>FPGA: I only know Xilinx &amp; haven't touched it for a few years now (even though this is an FPGA development diary)</li>
</ul>
<h1 id="are-you-using-chisel">Are you using Chisel?</h1>
<p><img src="https://community.cadence.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-01-06/Screen-Shot-2016_2D00_12_2D00_01-at-1.14.14-PM.jpg" alt="RISC-V 5th Workshop Highlights - Breakfast Bytes - Cadence Blogs - Cadence  Community" style="zoom:33%;" /></p>
<ul>
<li>A hardware building language based on Scala.</li>
<li>Not a high-level synthesis language.</li>
<li>SiFive's RISC-V IP use Chisel</li>
<li>Rocket-Chip : https://github.com/chipsalliance/rocket-chip</li>
<li>
<p>BOOM : https://github.com/riscv-boom/riscv-boom</p>
</li>
<li>
<p>Chisel Basics : "Chiselを始めたい人に読んで欲しい本" https://nextpublishing.jp/book/12162.html</p>
</li>
</ul>
<h1 id="how-chisel-generates-verilog">How Chisel generates Verilog</h1>
<ul>
<li>
<p>Chisel is a Scala DSL, so the Chisel Compiler is written in Scala.</p>
</li>
<li>
<p>Chisel Compiler generates an intermediate language called <span style="color:red">FIR (Flexible Interpretation Representation)</span>.</p>
</li>
<li>
<p>FIR has nothing to do with Scala's syntax</p>
</li>
<li>
<p>FIR is converted to Verilog using a converter called FIRRTL</p>
</li>
<li>
<p>FIRRTL is also written in Scala (FIR is not a Scala DSL, so I don't think it needs to be written in Scala...) [^circt].</p>
</li>
</ul>
<pre><code class="flow">st=&gt;inputoutput: Chisel(Scala)
op1=&gt;subroutine: Chisel Compiler
io=&gt;inputoutput: FIR(IR)
sub1=&gt;subroutine: FIRRTL Compiler
cond=&gt;inputoutput: Verilog

st(right)-&gt;op1(right)-&gt;io(right)-&gt;sub1(right)-&gt;cond
cond(yes)-&gt;e
cond(no)-&gt;op1
</code></pre>

<p>[^circt]: As a replacement for FIRRTL, a Chris Lattner-led tool called "CIRCT" has been developed using LLVM and MLIR https://github.com/llvm/circt</p>
<h1 id="whats-good-about-chisel">What's good about Chisel?</h1>
<ul>
<li>You can use the features of Scala, a software description language.</li>
<li>→ This results in Verilog engineers <span style="color:red">sometimes having to write seemingly incomprehensible and unintelligible statements</span>.</li>
</ul>
<h2 id="example-fir-filter">Example: FIR Filter</h2>
<p><img alt="fir_filter.PNG" src="../fir_filter.PNG" /></p>
<h3 id="answer-1-by-beginner">Answer 1. By beginner</h3>
<pre><code class="scala">// stage size is temporary 4
class My4ElementFir(b0: Int, b1: Int, b2: Int, b3: Int) extends Module {
  val io = IO(new Bundle {
    val in = Input(UInt(8.W))
    val out = Output(UInt(8.W))
  })

  val x_n1 = RegNext(io.in, 0.U)
  val x_n2 = RegNext(x_n1, 0.U)
  val x_n3 = RegNext(x_n2, 0.U)
  io.out := io.in * b0.U(8.W) + x_n1 * b1.U(8.W) +
             x_n2 * b2.U(8.W) + x_n3 * b3.U(8.W)
}
</code></pre>

<h3 id="answer-2-written-by-me-hardware-enginner">Answer 2. Written by me (hardware enginner)</h3>
<p><span style="color:red">Almost Verilog!</span></p>
<pre><code class="scala">class MyManyDynamicElementVecFir(length: Int) extends Module {
  val io = IO(new Bundle {
    val in = Input(UInt(8.W))
    val valid = Input(Bool())
    val out = Output(UInt(8.W))
    val consts = Input(Vec(length, UInt(8.W)))
  })

  val taps = Reg(Vec(length, UInt(8.W)));
  for (i &lt;- 0 until length) {
    if (i == 0) { when(io.valid) { taps(i) := io.in     } }
    else        { when(io.valid) { taps(i) := taps(i-1) } }
  }
  val w_fir_res = Wire(Vec(length, UInt(8.W)))
  for (i &lt;- 0 until length) {
    val w_tap_mul = Wire(UInt(8.W))
    w_tap_mul := taps(i) * io.consts(i)
    if (i == 0) { w_fir_res(i) := 0.U }
    else        { w_fir_res(i) := w_tap_mul + w_fir_res(i-1) }
  }
  io.out := w_fir_res(length-1)
}
</code></pre>

<h3 id="answer-3-written-by-chisel-expert">Answer 3. Written by Chisel Expert</h3>
<ul>
<li><span style="color:red">Can't understand?</span></li>
</ul>
<p>https://github.com/freechipsproject/chisel-bootcamp/blob/master/2.5_exercise.ipynb</p>
<pre><code class="scala">class MyManyDynamicElementVecFir(length: Int) extends Module {
  val io = IO(new Bundle {
    val in = Input(UInt(8.W))
    val valid = Input(Bool())
    val out = Output(UInt(8.W))
    val consts = Input(Vec(length, UInt(8.W)))
  })

  val taps = Seq(io.in) ++ Seq.fill(io.consts.length - 1)(RegInit(0.U(8.W)))
  taps.zip(taps.tail).foreach { case (a, b) =&gt; when (io.valid) { b := a } }

  io.out := taps.zip(io.consts).map { case (a, b) =&gt; a * b }.reduce(_ + _)
</code></pre>

<h1 id="btw-why-did-chisel-choose-scala">BTW, Why did Chisel choose <span style="color:green">Scala</span>?</h1>
<ul>
<li>Rumor: When we built the first version of Chisel at UCB, we used <span style="color:red">Ruby</span> and it compiled so slowly that we gave up.</li>
<li>
<p>Well, I don't think Scala compiles fast either.</p>
</li>
<li>
<p>Scala's feature: crazy operator overrides</p>
</li>
<li>Example 1 : <code>A := B</code> in normal Chisel description and <code>A := B</code> in TileLink have different meanings</li>
</ul>
<pre><code class="scala"> /** Connect this $coll to that $coll mono-directionally and element-wise.
    *
    * This uses the [[MonoConnect]] algorithm.
    *
    * @param that the $coll to connect to
    * @group Connect
    */
  final def := (that: Data)(implicit sourceInfo: SourceInfo, connectionCompileOptions: CompileOptions): Unit = this.connect(that)(sourceInfo, connectionCompileOptions) // scalastyle:ignore line.size.limit
</code></pre>

<ul>
<li>Example 2. Crazy AXI Bus connection (<code>src/main/scala/subsystem/Ports.scala</code>)</li>
</ul>
<pre><code class="scala"> mbus.coupleTo(s&quot;memory_controller_port_named_$portName&quot;) {
    (memAXI4Node
      :*= AXI4UserYanker()
      :*= AXI4IdIndexer(idBits)
      :*= TLToAXI4()
      :*= TLWidthWidget(mbus.beatBytes)
      :*= _)
  }
</code></pre>

<h1 id="back-on-topic-why-use-chisel">Back on topic: Why use Chisel?</h1>
<p><img alt="msyksphinz_chisel_tweet.PNG" src="../msyksphinz_chisel_tweet.PNG" /></p>
<h4 id="rant-if-you-want-to-make-regular-hardware-verilog-is-definitely-more-convenient"><span style="color:red">Rant: If you want to make regular hardware, Verilog is definitely more convenient: ！！！！ </span>.</h4>
<ul>
<li>Easier to write tests? → Isn't UVM more sophisticated?</li>
<li>Does it have better error detection? → The simulator is good enough to detect common writing errors.</li>
<li><span style="color:red">Reason</span> for using Chisel in the cluster as seen by me</li>
<li><span style="color:blue">It's unavoidable because Rocket-Chip is using it</span>.</li>
<li><span style="color:blue">I want to write something in a new language and have everyone say "wow"</span>.</li>
</ul>
<h4 id="so-whats-the-use-of-chisel"><span style="color:red">So what's the use of Chisel? </span></h4>
<ul>
<li><span style="color:blue">The evolution of technology has far outpaced the cycle of hardware design</span>.</li>
<li>Hardware engineers, are you catching up with the evolution of technology?</li>
<li>It takes two to three years to make a chip. It takes two to three years to make a chip. Can you make a cutting-edge AI chip with this?</li>
<li>In the age of DSA, we have to build in <span style="color:red">low volume, high variety</span>.</li>
<li>(Not that it matters.) The time should come when chips can be easily woken up by the weak in small quantities and high variety.</li>
<li>How do you manage the "complexity" of hardware?</li>
</ul>
<p><img alt="hardware_difficulty" src="../hardware_difficulty.PNG" /></p>
<h1 id="an-example-of-how-to-use-chisel-diplomacy">An example of how to use Chisel: <span style="color:red">Diplomacy</span></h1>
<ul>
<li>Parameter Negotiation Framework for generating parameterized protocol implementation.</li>
</ul>
<p><img alt="diplomacy.PNG" src="../diplomacy.PNG" /></p>
<h1 id="where-did-diplomacy-come-from">Where did Diplomacy come from?</h1>
<ul>
<li>Andrew Waterman's PhD Thesis</li>
<li>Design of the RISC-V Instruction Set Architecture</li>
<li>https://people.eecs.berkeley.edu/~krste/papers/EECS-2016-1.pdf</li>
<li>Yunsup Lee's PhD Thesis</li>
<li>Decoupled Vector-Fetch Architecture with a Scalarizing Compiler</li>
<li>https://people.eecs.berkeley.edu/~krste/papers/EECS-2016-117.pdf</li>
<li>Henry Cook's PhD Thesis</li>
<li><span style="color:red">Productive Design of Extensible On-Chip Memory Hierarchies</span>.</li>
<li>The basic idea of Diplomacy is described in this paper</li>
<li>https://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-89.pdf</li>
</ul>
<h1 id="what-we-want-to-achieve-with-diplomacy">What we want to achieve with Diplomacy</h1>
<ul>
<li>Flexible configuration using a single design</li>
<li>Multiple CPU configurations (RV64 / RV32) from a single design</li>
<li>Multiple CPU configurations (RV64 / RV32)</li>
<li>Multiple bus and cache configurations<ul>
<li>Number of cores, bus width, cache size, SoC configuration</li>
</ul>
</li>
</ul>
<p><img alt="image-20201130123338375" src="../diplomacy_SoC_variation.PNG" /></p>
<h3 id="one-example-sifives-core-ip-generator">One example: SiFive's Core IP Generator</h3>
<ul>
<li>https://scs.sifive.com/core-designer/</li>
</ul>
<p><img alt="coreip_generator.PNG" src="../coreip_generator.PNG" /></p>
<h1 id="if-you-want-to-develop-with-chisel-diplomacy-use-intellij-idea">If you want to develop with Chisel + Diplomacy, use IntelliJ IDEA!</h1>
<p><span style="color:red">Auto Completion feature is mandatory.</span></p>
<p><img alt="image-20201212012922069" src="../intellij_auto_completion.PNG" /></p>
<h1 id="misunderstandings-diplomacy-can-only-be-used-with-tilelink">Misunderstandings: Diplomacy can only be used with TileLink?</h1>
<p>No, Diplomacy is a Chisel library, so you don't need to use TileLink to use it.</p>
<h2 id="example-adder-for-multiple-inputs-connected-with-diplomacy">Example: Adder for Multiple Inputs connected with Diplomacy</h2>
<p><img alt="multiple_inputs_adder.PNG" src="../multiple_inputs_adder.PNG" /></p>
<p>Here are the three modules that we need to decipher</p>
<ul>
<li><code>AdderDriver</code> : A driver to send random values to the adder.</li>
<li><code>AdderNode</code> : The adder itself, to which two or more <code>AdderDrivers</code> are connected to add all their values together and output the result.</li>
<li><code>AdderMonitor</code> : A monitor. Monitor<code>: A monitor that checks the values sent out by the</code>AdderDriver<code>against the results of addition generated by the</code>AdderNode`.</li>
</ul>
<h3 id="adderdriver">AdderDriver.</h3>
<p>Driver to send random values to the adder. Key points for reading and understanding <code>AdderDriver</code>: 1.</p>
<ol>
<li><span style="color:red">What is <code>val node = new AdderDriverNode</code>? </span>.</li>
<li>what is <span style="color:red"><code>new LazyModuleImp(this)</code>? </span> 3.</li>
</ol>
<pre><code class="scala">// class ModuleName extends LazyModule If you think of it as a module for connecting via Diplomacy.
class AdderDriver(width: Int, numOutputs: Int)(implicit p: Parameters) extends LazyModule {
    // 1. what is AdderDriverNode and what is the role of &quot;node&quot; in the first place?
    val node = new AdderDriverNode(Seq.fill(numOutputs)(DownwardParam(width)))

    // 2. What is LazyModuleImp() and what role does it have in Diplomacy?
    lazy val module = new LazyModuleImp(this) {
        ...
        // drive signals
        node.out.foreach { case (addend, _) =&gt; addend := randomAddend }
    }
}

// AdderDriverNode is created by inheriting from the SourceNode class
class AdderDriverNode(widths: Seq[DownwardParam])(implicit valName: ValName)
  extends SourceNode(AdderNodeImp)(widths)
</code></pre>

<ul>
<li><code>SourceNode</code> is used for the node that will be the master.</li>
<li><code>SinkNode</code> is used for nodes that are slaves.</li>
<li><code>AdapterNode</code> connects multiple masters and multiple slaves. The number of masters and slaves should be the same.</li>
<li><code>NexusNode</code> is used to connect multiple masters and multiple slaves. The number of masters and slaves does not have to be the same.</li>
</ul>
<h4 id="1-node-for-connecting-between-modules">1. node : for connecting between modules</h4>
<p><code>node</code> is a communication port for communication between modules in Diplomacy. It has the role of exchanging various parameters between <code>nodes</code> and mediating the parameters.</p>
<p>There are two important elements in <code>node</code>.</p>
<ul>
<li>
<p><code>bundle</code> : Contains the I/O ports connected by Diplomacy. In this case, it just contains a bundle of signals for sending random values.</p>
</li>
<li>
<p><code>edge</code> : Contains a set of parameters for connecting nodes of Diplomacy. These parameters are communicated between the nodes to make the final inter-node parameter adjustment (Diplomacy).</p>
</li>
</ul>
<pre><code class="scala">object AdderNodeImp extends SimpleNodeImp[DownwardParam, UpwardParam, EdgeParam, UInt] {
  // Edge : Contains a set of parameters for connecting Diplomacy nodes.
  def edge(pd: DownwardParam, pu: UpwardParam, p: Parameters, sourceInfo: SourceInfo) = {
    if (pd.width &lt; pu.width) EdgeParam(pd.width) else EdgeParam(pu.width)
  }

  // Contains the I/O ports connected by Diplomacy.
  // UInt(e.width.W) : e is the EdgeParam, i.e. the edge parameter
  def bundle(e: EdgeParam) = UInt(e.width.W)

  def render(e: EdgeParam) = RenderedEdge(&quot;blue&quot;, s &quot;width = ${e.width}&quot;)
}
</code></pre>

<h4 id="2-lazymoduleimp-the-part-that-implements-the-circuit-based-on-the-information-of-node">2. <code>LazyModuleImp</code> : The part that implements the circuit based on the information of node.</h4>
<ol>
<li><code>LazyModuleImp</code> : The part that implements the circuit based on the information of <code>node</code>.</li>
</ol>
<pre><code class="scala">  val node = new AdderDriverNode(Seq.fill(numOutputs)(DownwardParam(width)))

  lazy val module = new LazyModuleImp(this) {
    // Extract bit width information from all node edges
    val negotiatedWidths = node.edges.out.map(_.width)
    // Do all inter-node connection lines have the same number of bits?
    require(negotiatedWidths.forall(_ == negotiatedWidths.head), &quot;outputs must all have agreed on same width&quot;)

    // Use the head node's information if it is available (well, it doesn't matter which node's information is used)
    val finalWidth = negotiatedWidths.head

    // generate random numbers by FibonacciLFSR module
    val randomAddend = FibonacciLFSR.maxPeriod(finalWidth)

    // send random numbers to all output nodes
    node.out.foreach { case (addend, _) =&gt; addend := randomAddend }
  }
</code></pre>

<h3 id="if-you-use-diplomacy-use-yed-to-check-the-node-graph-diagram">If you use Diplomacy, use yEd to check the node graph diagram!</h3>
<p><img alt="yed_adder_node_graph.PNG" src="../yed_adder_node_graph.PNG" /></p>
<div align="center">Figure. Diagram of the Adder graph generated by yEd.</div>

<ul>
<li>A more complex example: Node connection diagram for a 4-core configuration in Freedom-SoC.</li>
</ul>
<p><img alt="freedom_diplomacy_node.PNG" src="../freedom_diplomacy_node.PNG" /></p>
<div align="center">Figure. Connection diagram of freedom SoC nodes</div>

<h1 id="home-made-cpu-using-tilelink-various-bus-connections">Home-made CPU using TileLink + various bus connections</h1>
<h3 id="try-to-make-your-own-cpu">Try to make your own CPU.</h3>
<ul>
<li>I made my own CPU using Chisel, and connected it to TileLink to make a simple multi-core system.</li>
</ul>
<h4 id="cpu-core-i-made-rv64-with-simple-5-stage-pipeline">CPU core I made: RV64 with simple 5-stage pipeline.</h4>
<p>I made a CPU core that can run <code>riscv-tests</code> for now, though I haven't tested it properly.</p>
<p>https://github.com/msyksphinz-self/chisel-soc/tree/main/src/main/scala/core</p>
<p><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/m/msyksphinz/20181224/20181224131915.png" alt="RISC-V pipeline processor designed with Chisel without any waveforms. I designed a pipeline processor - FPGA development diary" style="zoom:50%;" /></p>
<ul>
<li>The fetch bus / data bus is very simple (non-TileLink / non-AXI bus)</li>
</ul>
<p>https://github.com/msyksphinz-self/chisel-soc/blob/main/src/main/scala/core/cpu_bus.scala#L17 (link to <code>InstBus</code>)</p>
<p>https://github.com/msyksphinz-self/chisel-soc/blob/main/src/main/scala/core/cpu_bus.scala#L30 (link to <code>DataBus</code>)</p>
<h3 id="how-do-i-integrate-my-homebrew-cpu-into-tilelink-to-build-a-soc">How do I integrate my homebrew CPU into TileLink to build a SoC?</h3>
<ol>
<li>wrap your own CPU with LazyModule. 2.</li>
<li>define a node of <code>TileLink</code>. 3.</li>
<li>connect the node of TileLink to the node of your CPU.</li>
</ol>
<p><img alt="image-20201212151257774" src="../cpu_configuration.PNG" /></p>
<div align="center">Figure. Interface configuration of home-made CPU</div>

<ul>
<li>There are two TileLink nodes available.</li>
<li>For instruction fetching</li>
<li>For data access</li>
<li>Both of them are TileLink, but I was forced to replace them because my own CPU has its own bus protocol.</li>
<li>Now, the <code>CoreTop</code> module is replaced with a module that has two TileLink interfaces.</li>
</ul>
<pre><code class="scala">    // Pull the ClientNode of the instruction/data bus defined in TileLink into the internal
    val (inst_out, inst_edge) = inst_node.out(0)
    val (data_out, data_edge) = data_node.out(0)
    val baseEnd = 0
    val (sizeEnd, sizeOff) = (inst_edge.bundle.sizeBits + baseEnd, baseEnd)
    val (sourceEnd, sourceOff) = (inst_edge.bundle.sourceBits + sizeEnd, sizeEnd)
    val beatBytes = inst_edge.bundle.dataBits

    // Define the instance of your own CPU
    val cpu = Module(new Cpu(conf, hartid))

    // Connect TileLink's fetch port signal to the fetch port of the home-made CPU (proprietary protocol)
    inst_out.a.valid := cpu.io.inst_bus.req
    inst_out.a.bits.address := cpu.io.inst_bus.addr
    inst_out.a.bits.opcode := TLMessages.Get
    ...
    cpu.io.inst_bus.ready := inst_out.a.ready
    cpu.io.inst_bus.ack := inst_out.d.valid
    cpu.io.inst_bus.rddata := inst_out.d.bits.data.asSInt

    // Connect TileLink's data access port signal to the data access port (proprietary protocol) of the home-made CPU
    data_out.a.valid := cpu.io.data_bus.req
    data_out.a.bits.address := cpu.io.data_bus.addr
    data_out.a.bits.opcode := TLMessages.Get
    ...
    cpu.io.data_bus.ack := data_out.d.valid
    cpu.io.data_bus.rddata := data_out.d.bits.data.asSInt
</code></pre>

<h3 id="create-a-soc-using-coretop-with-tilelink-module">Create a SoC using CoreTop with TileLink module.</h3>
<p>Create a <code>CoreTop</code> and a <code>CoreComplex</code> module with a memory module and connect them.</p>
<pre><code class="scala">class core_complex[Conf &lt;: RVConfig]
  (conf: Conf, numCores: Int, ramBeatBytes: Int, txns: Int)(implicit p: Parameters)
  extends LazyModule {
  // Data loader for data access to memory from outside.
  val loader = LazyModule(new loader(&quot;loader&quot;))

  // CPU cores (instantiate multiple for numCore)
  val core   = Seq.tabulate(numCores) { case i =&gt; LazyModule(new CoreTop(conf, i, &quot;core&quot; + i.toString)) }
  // TileLink crossbar
  val xbar   = LazyModule(new TLXbar)
  // memory with TileLink interface
  val memory = LazyModule(new TLRAM(AddressSet(0x80000000L, 0x0ffff), beatBytes = ramBeatBytes))

  // Connect the instruction fetch port and data port of the CPU core to the crossbar
  xbar.node := loader.node
  core.foreach { case (core) =&gt; {
    //
    xbar.node := TLDelayer(0.1) := core.inst_node
    xbar.node := TLDelayer(0.1) := core.data_node
  }
  }
  // Connect the data loader to the crossbar
  memory.node := xbar.node

</code></pre>

<p><img alt="image-20201212152847526" src="../core_complex_core1.PNG" /></p>
<div align="center">Figure. Connecting a home-made CPU to memory through TileLink to configure a simple SoC.</div>

<h3 id="set-numcores-to-1-for-easy-multi-core-configuration">Set <code>numCores</code> to &gt;1 for easy multi-core configuration.</h3>
<p>With the above description of Chisel, you can easily make it multi-core. Just set <code>nCores</code> to 2, 3, ... to <code>nCores</code>, and multiple CPUs will be connected to the crossbar automatically.</p>
<p><img alt="image-20201212153430326" src="../core_complex_coreN.PNG" /></p>
<div align="center">Figure. Connecting a home-made CPU to memory through TileLink. When connection=4</div>

<ul>
<li>A simple simulation example. At first, the memory access is well arbitrated even when 4 cores request at the same time.</li>
</ul>
<p><img alt="multicore_memory_access" src="../multicore_memory_access.PNG" /></p>
<div align="center">Figure . RTL simulation in a four-core configuration.</div>

<ul>
<li>Example of Diplomacy node configuration with 4-core configuration</li>
</ul>
<p><img alt="multicore_diplomacy_node.PNG" src="../multicore_diplomacy_node.PNG" /></p>
<div align="center">Figure. Diplomacy connection diagram for a four-core configuration.</div>

<h1 id="lets-learn-how-to-connect-the-bus-using-rockettile-as-an-example">Let's learn how to connect the bus using RocketTile as an example.</h1>
<ul>
<li>Typical CPU implementation of RISC-V: Rocket-Chip https://github.com/chipsalliance/rocket-chip</li>
</ul>
<h3 id="rocket-chip-generator-do-you-know-why-its-named-generator">Rocket-Chip Generator: Do you know why it's named "Generator"?</h3>
<ul>
<li>Rocket-Chip is a comprehensive package that includes not only the design, but also Diplomacy for coordination between designs, Chisel implementation, and FIRRTL implementation itself.</li>
<li>It is called "Generator" because it includes not only the Scala implementation but also all the engines to generate the hardware.</li>
</ul>
<h2 id="lets-look-at-the-diplomacy-configuration-of-defaultconfig-of-rocket-chip">Let's look at the Diplomacy configuration of <code>DefaultConfig</code> of Rocket-Chip.</h2>
<p>The bus connection of Rocket-Chip is basically configured using TileLink and Diplomacy.</p>
<p><img alt="rocket_chip_diplomacy_node.PNG" src="../rocket_chip_diplomacy_node.PNG" /></p>
<p>Let's break down little more.</p>
<p>Let's take a look at the bus connections.</p>
<h2 id="connect-devices-using-diplomacy-with-rockettile">Connect devices using Diplomacy with RocketTile</h2>
<ul>
<li>RocketTile : One basic CPU core element that contains all the basic components such as RocketChip and DCache.</li>
<li>In CPU vendors, it is also called "CoreComplex"... Why do they call it "Core Complex"? I'm not sure.</li>
</ul>
<h3 id="simple-memory-map-by-rocket-chip">(Simple) memory map by Rocket-Chip.</h3>
<table>
<thead>
<tr>
<th>Start Address</th>
<th>Stop Address</th>
<th>Attributes</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0000_0000</td>
<td>0x0000_1000</td>
<td>ARWX</td>
<td>debug-controller@0</td>
</tr>
<tr>
<td>0x0000_3000</td>
<td>0x0000_4000</td>
<td>ARWX</td>
<td>error-device@3000</td>
</tr>
<tr>
<td>0x0001_0000</td>
<td>0x0002_0000</td>
<td>RX</td>
<td>rom@10000</td>
</tr>
<tr>
<td>0x0200_0000</td>
<td>0x0200_1000</td>
<td>ARW</td>
<td>clint@2000000</td>
</tr>
<tr>
<td>0x0c00_0000</td>
<td>0x1000_0000</td>
<td>ARW</td>
<td>interrupt_controller</td>
</tr>
<tr>
<td>0x6000_0000</td>
<td>0x8000_0000</td>
<td>RWX</td>
<td>mmio-port-axi4@60000000</td>
</tr>
<tr>
<td>0x8000_0000</td>
<td>0x9000_0000</td>
<td>RWXC</td>
<td>memory@8000_0000</td>
</tr>
</tbody>
</table>
<h2 id="verilog-structure-of-rockettile">Verilog structure of RocketTile</h2>
<pre><code class="verilog">module RocketTile( // @[:freechips.rocketchip.system.DefaultConfig.fir@200426.2]

  TLXbar_8 tlMasterXbar ();

  IntXbar_4 intXbar ();

  DCache dcache ();

  Frontend frontend ();

  TLBuffer_9 buffer ();

  IntSyncCrossingSink intsink ();

  IntSyncCrossingSink_1 intsink_1 ();

  IntSyncCrossingSink_2 intsink_2 ();

  IntSyncCrossingSink_2 intsink_3 ();

  FPU fpuOpt ();

  HellaCacheArbiter dcacheArb ();

  PTW ptw ();

  Rocket core ();
</code></pre>

<p>I made a diagram by extracting the important parts. <span style="color:blue">Blue is LazyModule</span>, <span style="color:red">Red is NormalModule</span>.</p>
<p><img alt="rocket_tile.PNG" src="../rocket_tile.PNG" /></p>
<p>So, how can we decipher this from Scala? Let's take a look at some examples to see how the nodes are connected.</p>
<ul>
<li>Let's take a look at <code>RocketTile.scala</code>.</li>
</ul>
<pre><code class="scala">class RocketTile private(
      val rocketParams: RocketTileParams,
      crossing: ClockCrossingType,
      lookup: LookupByHartIdImpl,
      q: Parameters,
      logicalTreeNode: LogicalTreeNode)
    extends BaseTile(rocketParams, crossing, lookup, q)
    with SinksExternalInterrupts
    with SourcesExternalNotifications
    with HasLazyRoCC  // implies CanHaveSharedFPU with CanHavePTW with HasHellaCache
    with HasHellaCache
    with HasICacheFrontend
{
/* ... */
    override lazy val module = new RocketTileModuleImp(this)
/* ... */
}
</code></pre>

<ul>
<li>What is the implementation of <code>RocketTileModuleImp</code>?</li>
</ul>
<pre><code class="scala">// &quot;outer&quot; corresponds to the RocketTile above
class RocketTileModuleImp(outer: RocketTile) extends BaseTileModuleImp(outer)
    with HasFpuOpt
    with HasLazyRoCCModule
    with HasICacheFrontendModule {
/* ... */
  val core = Module(new Rocket(outer)(outer.p))
/* ... */
  outer.frontend.module.io.cpu &lt;&gt; core.io.imem
  dcachePorts += core.io.dmem // TODO outer.dcachePorts += () =&gt; module.core.io.dmem ??

  /* For FPU, depending on options, connect */
  fpuOpt foreach { fpu =&gt; core.io.fpu &lt;&gt; fpu.io }

  /* Connect DCache to the data cache arbiter */
  dcacheArb.io.requestor &lt;&gt; dcachePorts
  ptw.io.requestor &lt;&gt; ptwPorts

</code></pre>

<ul>
<li>FPU Connection  (we are not using Diplomacy here)</li>
</ul>
<p><img alt="fpu_diplomacy.PNG" src="../fpu_diplomacy.PNG" /></p>
<ul>
<li>DCache Connection</li>
</ul>
<p><img alt="image-20201212001639688" src="../dcache_diplomacy.PNG" /></p>
<h2 id="lets-read-and-understand-the-configuration-of-the-soc-part-of-rocket-chip">Let's read and understand the configuration of the SoC part of Rocket-Chip.</h2>
<ul>
<li>When Verilog is generated by Rocket-Chip Generator, a top module called <code>TestHarness</code> is generated, which is a module for test execution.</li>
<li>
<p>This is also all generated from Chisel without the help of Verilog.</p>
</li>
<li>
<p><code>src/main/scala/system/TestHarness.scala</code></p>
</li>
</ul>
<pre><code class="scala">class TestHarness()(implicit p: Parameters) extends Module {
  val io = new Bundle {
    val success = Bool(OUTPUT)
  }

  val ldut = LazyModule(new ExampleRocketSystem) // Instantiate ExampleRocketSystem.
  val dut = Module(ldut.module) // ExmapleRocketSystem is a LazyModule, so extract the entity inside it as dut.

  dut.dontTouchPorts()
  dut.tieOffInterrupts()
  SimAXIMem.connectMem(ldut) // instantiate the object SimAXIMem and connect the memory port of ldut
  SimAXIMem.connectMMIO(ldut) // object Instantiate SimAXIMem and connect ldut's MMIO port
  ldut.l2_frontend_bus_axi4.foreach(_.tioff) // ldut's frontend port should be Tie Zero
</code></pre>

<ul>
<li><code>SimAXIMem.connectMem(ldut)</code>の部分を除いてみる</li>
</ul>
<pre><code class="scala">  def connectMem(dut: CanHaveMasterAXI4MemPort)(implicit p: Parameters): Seq[SimAXIMem] = {
    // mem_axi4 in ExampleRocketSystem shows the io port
    // dut.memAXI4Node.in is the SlavePort node of the LazyModule
    dut.mem_axi4.zip(dut.memAXI4Node.in).map { case (io, (_, edge)) =&gt;
      // Newly instantiate AXI4 memory
      // The size of the memory depends on the edge information of the AXI node
      val mem = LazyModule(new SimAXIMem(edge, size = p(ExtMem).get.master.size))
      Module(mem.module).suggestName(&quot;mem&quot;)
      // Connect the I/O port of the memory instance to the AXI port of the ldut
      mem.io_axi4.head &lt;&gt; io
      mem
    }
  }
</code></pre>

<ul>
<li>AXI4メモリポートの仕組み (<code>src/main/scala/subsystem/Ports.scala</code>)</li>
</ul>
<pre><code class="scala">/** Adds a port to the system intended to master an AXI4 DRAM controller. */
trait CanHaveMasterAXI4MemPort { this: BaseSubsystem =&gt;
  private val memPortParamsOpt = p(ExtMem)
  private val portName = &quot;axi4&quot;
  private val device = new MemoryDevice
  private val idBits = memPortParamsOpt.map(_.master.idBits).getOrElse(1)
  // Create a Diplomacy slave node for AXI4.
  // The reason why it is a slave is because the internal TileLink (master) is the master and the AXI4 node is the slave.
  val memAXI4Node = AXI4SlaveNode(memPortParamsOpt.map({ case MemoryPortParams(memPortParams, nMemoryChannels) =&gt;
    Seq.tabulate(nMemoryChannels) { channel =&gt;
      val base = AddressSet.misaligned(memPortParams.base, memPortParams.size)
      val filter = AddressSet(channel * mbus.blockBytes, ~((nMemoryChannels-1) * mbus.blockBytes))
...
  // Connect the node to the mbus (memory bus).
  mbus.coupleTo(s&quot;memory_controller_port_named_$portName&quot;) {
    (memAXI4Node                        // AXI memory node
      :*= AXI4UserYanker()              // ↑ Add a User field to the AXI4 protocol
      :*= AXI4IdIndexer(idBits)         // ↑ Extend the ID bits of AXI4
      :*= TLToAXI4()                    // ↑ Change the protocol to AXI4
      :*= TLWidthWidget(mbus.beatBytes) // ↑ Change bus width of mbus(TileLink)
      :*= _)                            //  this means mbus
  }

  val mem_axi4 = InModuleBody { memAXI4Node.makeIOs() }
}
</code></pre>

<ul>
<li>Note : Why is the MMIO connected to the memory? This is a test environment, so the memory is automatically connected.</li>
</ul>
<p><img alt="image-20201212135420935" src="../TestHarness.PNG" /></p>
<h2 id="how-to-create-a-configurable-module-using-config-parameter">How to create a configurable module using Config / Parameter.</h2>
<h2 id="motivation-why-does-rocket-chip-have-so-many-variations-of-verilog-that-can-be-generated"><span style="color:blue">Motivation: Why does Rocket-Chip have so many variations of Verilog that can be generated? </span></h2>
<pre><code class="sh">$ make CONFIG=DefaultConfig         # Generate RV64GC configuration.
$ make CONFIG=RV32Config            # generate RV32GC configuration
$ make CONFIG=DualCoreConfig        # Generate SoC with 2-core configuration.
$ make CONFIG=RoCCExampleConfig     # Generate a configuration with RoCC (Rocket Custom Coprocessor).
</code></pre>

<h3 id="because-each-function-is-divided-while-maintaining-modularity">Because each function is divided while maintaining Modularity.</h3>
<p><img alt="image-20201213122345167" src="../rocket_chip_configurabilty.PNG" /></p>
<div align="center">Figure. In the Rocket-Chip + SoC configuration, each module is designed to be highly independent.</div>

</div>

<ul>
<li><code>src/main/scala/system/Configs.scala</code></li>
</ul>
<pre><code class="scala">class BaseConfig extends Config(
  new WithDefaultMemPort() ++
  new WithDefaultMMIOPort() ++
  new WithDefaultSlavePort() ++
  new WithTimebase(BigInt(1000000)) ++ // 1 MHz
  new WithDTS(&quot;freechips,rocketchip-unknown&quot;, Nil) ++
  new WithNExtTopInterrupts(2) ++
  new BaseSubsystemConfig()
)

class DefaultConfig extends Config(new WithNBigCores(1) ++ new WithCoherentBusTopology ++ new BaseConfig)
 
class DefaultBufferlessConfig extends Config(new WithBufferlessBroadcastHub ++ new DefaultConfig)
class DefaultSmallConfig extends Config(new WithNSmallCores(1) ++ new WithCoherentBusTopology ++ new BaseConfig)
class DefaultRV32Config extends Config(new WithRV32 ++ new DefaultConfig)
 
class DualBankConfig extends Config(new WithNBanks(2) ++ new DefaultConfig)
class DualCoreConfig extends Config(new WithNBigCores(2) ++ new WithCoherentBusTopology ++ new BaseConfig)
class DualChannelConfig extends Config(new WithNMemoryChannels(2) ++ new DefaultConfig)
class EightChannelConfig extends Config(new WithNMemoryChannels(8) ++ new DefaultConfig)
 
class DualChannelDualBankConfig extends Config(
  new WithNMemoryChannels(2) ++
  new WithNBanks(4) ++ new DefaultConfig)
 
class RoccExampleConfig extends Config(new WithRoccExample ++ new DefaultConfig)
</code></pre>

<p>What does the above <code>class DualBankConfig extends Config(new WithNBanks(2) ++ new DefaultConfig)</code> mean? See about <code>Config</code> and <code>Parameter</code>.</p>
<h2 id="some-techniques-for-passing-parameters-config">Some techniques for passing parameters: Config</h2>
<h3 id="concept-of-config-build-a-reference-table-map-function-of-apply-this-parameter-to-this-module">Concept of Config: build a reference table (map function) of "<span style="color:blue">apply this parameter to this module</span>".</h3>
<h3 id="verilog-put-parameters-down-from-the-top-centralized-management-by-package">⇔ Verilog: "<span style="color:red">Put parameters down from the top / centralized management by package</span>".</h3>
<p><img alt="image-20201213142616432" src="../verilog_parameter_structure.PNG" /></p>
<div align="center">図. Verilogのパラメータを階層で降ろしていく（なんとなくの）イメージ</div>

<h4 id="in-the-case-of-chisels-config-create-a-dictionary-of-keys-and-get-parameters-from-the-keys-you-need-in-the-module">In the case of Chisel's Config: Create a dictionary of keys and get parameters from the keys you need in the module.</h4>
<pre><code class="sh">$ grep -h -R Key | grep Field
</code></pre>

<pre><code class="scala">case object APBDebugRegistersKey extends Field[Map[Int, Seq[RegField]]](Map())
case object DebugModuleKey extends Field[Option[DebugModuleParams]](Some(DebugModuleParams()))
case object DebugModuleHartSelKey extends Field(DebugModuleHartSelFuncs())
case object JtagDTMKey extends Field[JtagDTMConfig](new JtagDTMKeyDefault())
case object CLINTKey extends Field[Option[CLINTParams]](None)
...
case object SubsystemDriveAsyncClockGroupsKey extends Field[Option[ClockGroupDriverParameters]](Some(ClockGroupDriverParameters(1)))
case object AsyncClockGroupsKey extends Field[ClockGroupEphemeralNode](ClockGroupEphemeralNode()(ValName(&quot;async_clock_groups&quot;)))
case object BroadcastKey extends Field(BroadcastParams())
case object RocketTilesKey extends Field[Seq[RocketTileParams]](Nil)
case object RocketCrossingKey extends Field[Seq[RocketCrossingParams]](List(RocketCrossingParams()))
case object PeripheryMaskROMKey extends Field[Seq[MaskROMParams]](Nil)
...
case object PSDTestModeBroadcastKey extends Field(
</code></pre>

<p>You can think of it as being like making a dictionary:.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th></th>
<th>Type</th>
<th>Explain</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>APBDebugRegistersKey</code></td>
<td>→</td>
<td><code>Map[Int, Seq[RegField]]</code></td>
<td></td>
</tr>
<tr>
<td><code>RocketTilesKey</code></td>
<td>→</td>
<td><code>Seq[RocketTileParams]]</code></td>
<td>Why are they enclosed in <code>Seq</code> -&gt; <br />RocketTiles are placed in multiple locations in multi-core configurations, so <code>RocketTileParams</code> are duplicated for each Tile.</td>
</tr>
<tr>
<td><code>PeripheryMaskROMKey</code></td>
<td>→</td>
<td><code>Seq[MaskROMParams]</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>For example, <code>RocketTileParams</code> is defined as follows: <code>RocketTileParams</code> is just like <code>package</code> in System Verilog?</p>
<pre><code class="scala">case class RocketCoreParams(
  bootFreqHz: BigInt = 0,
  useVM: Boolean = true,
  useUser: Boolean = false,
  useDebug: Boolean = true,
...
</code></pre>

<p>Now let's go back to the definition of <code>DualCoreConfig</code> again...</p>
<ul>
<li><code>DualCoreConfig</code> inherits from the <code>Config</code> class. You can think of the <code>Config</code> class as a set of dictionary table conversion functions based on the View. These sets of dictionary table conversion functions are finally aggregated as <code>Parameter</code> and passed to the design.</li>
</ul>
<p><img alt="dualcoreconfig.PNG" src="../dualcoreconfig.PNG" /></p>
<p>In each module, call the parameters defined here to get the concrete values.</p>
<ul>
<li><code>src/main/scala/rocket/RocketCore.scala</code></li>
</ul>
<pre><code class="scala">trait HasRocketCoreParameters extends HasCoreParameters {
  lazy val rocketParams: RocketCoreParams = tileParams.core.asInstanceOf[RocketCoreParams]

  val fastLoadWord = rocketParams.fastLoadWord
  val fastLoadByte = rocketParams.fastLoadByte

  val mulDivParams = rocketParams.mulDiv.getOrElse(MulDivParams()) // TODO ask andrew about this

  require(!fastLoadByte || fastLoadWord)
}
</code></pre>

<pre><code class="scala">@chiselName
class Rocket(tile: RocketTile)(implicit p: Parameters) extends CoreModule()(p)
    with HasRocketCoreParameters
    with HasCoreIO {

  val clock_en_reg = RegInit(true.B)
...
  // multiplier and divider
  val div = Module(new MulDiv(if (pipelinedMul) mulDivParams.copy(mulUnroll = 0) else mulDivParams, width = xLen))
  div.io.req.valid := ex_reg_valid &amp;&amp; ex_ctrl.div
  div.io.req.bits.dw := ex_ctrl.alu_dw
  div.io.req.bits.fn := ex_ctrl.alu_fn
...
</code></pre>

<ul>
<li><code>src/main/scala/rocket/Multiplier.scala</code></li>
</ul>
<pre><code class="scala">class MulDiv(cfg: MulDivParams, width: Int, nXpr: Int = 32) extends Module {
  private def minDivLatency = (cfg.divUnroll &gt; 0).option(if (cfg.divEarlyOut) 3 else 1 + w/cfg.divUnroll)
  private def minMulLatency = (cfg.mulUnroll &gt; 0).option(if (cfg.mulEarlyOut) 2 else w/cfg.mulUnroll)
  def minLatency: Int = (minDivLatency ++ minMulLatency).min

  val io = IO(new MultiplierIO(width, log2Up(nXpr)))
...
  val req = Reg(chiselTypeOf(io.req.bits))
  val count = Reg(UInt(log2Ceil(
    ((cfg.divUnroll != 0).option(w/cfg.divUnroll + 1).toSeq ++
     (cfg.mulUnroll != 0).option(mulw/cfg.mulUnroll)).reduce(_ max _)).W))

</code></pre>

<h3 id="how-to-use-here-site-up-etc">How to use <code>here()</code>, <code>site()</code>, <code>up()</code>, etc.</h3>
<ul>
<li>If you want to use the value of another parameter to calculate a parameter used in <code>Config</code>, you can do the following in Verilog.</li>
</ul>
<pre><code class="verilog">localparam param1 = 100;
localparam param2 = param1 * 100;
</code></pre>

<p>If you try to achieve this in Chisel, it will look like this. The <code>BusWidthBytes</code> parameter is used to calculate the address size.</p>
<pre><code class="scala">class Bus128BitConfig extends Config((site, here, up) =&gt; {
  case BusWidthBytes =&gt; 128 / 8
  // BusWidthBytes is a case class, so it is not an integer
  case AddrSize =&gt; 0x100 * BusWidthBytes
})

class Bus64BitConfig extends Config((site, here, up) =&gt; {
  case BusWidthBytes =&gt; 64 / 8
  // BusWidthBytes is a case class, so it is not an integer
  case AddrSize =&gt; 0x200 * BusWidthBytes
})

[error] /home/msyksphinz/work/riscv/chisel-development/minimal-diplomacy/src/main/scala/core_complex/Configs.scala:11:26: overloaded method value * with alternatives:
[error]   (x: Double)Double &lt;and&gt;
[error]   (x: Float)Float &lt;and&gt;
[error]   (x: Long)Long &lt;and&gt;
[error]   (x: Int)Int &lt;and&gt;
[error]   (x: Char)Int &lt;and&gt;
[error]   (x: Short)Int &lt;and&gt;
[error]   (x: Byte)Int
[error]  cannot be applied to (core_complex.BusWidthBytes.type)
[error]   case AddrSize =&gt; 0x100 * BusWidthBytes  // &lt;-- BusWidthBytes is not a number!
[error]                          ^
</code></pre>

<p>As you can see, <code>BusWidthBytes</code> itself is a case class, so you can't use it directly as a value. So, we use information such as <code>here()</code> to refer to a value in the same <code>Config</code> for dictionary search.</p>
<pre><code class="scala">class Bus128BitConfig extends Config((site, here, up) =&gt; {
  case BusWidthBytes =&gt; 128 / 8
  case AddrSize =&gt; 0x100 * here(BusWidthBytes)
})

class Bus64BitConfig extends Config((site, here, up) =&gt; {
  case BusWidthBytes =&gt; 64 / 8
  case AddrSize =&gt; 0x200 * here(BusWidthBytes)
})
// Bus128BitConfigで構成したTLRAM, 12ビットのバス幅で構成される
module TLRAM(
  input         clock,
  input         reset,
  input         auto_in_a_valid,
  input  [2:0]  auto_in_a_bits_opcode,
  input  [11:0] auto_in_a_bits_address,
  input  [31:0] auto_in_a_bits_data,
  output        auto_in_d_valid,
  output [2:0]  auto_in_d_bits_opcode,
  output [31:0] auto_in_d_bits_data
);
</code></pre>

<p>一方で、<code>site()</code>を使用するとより上位のConfigを使用するようになる。例えば<code>Default2Config</code>では以下のように構成している。</p>
<ul>
<li><code>sites()</code>を使用するケース：<code>Bus128BitConfig</code>で<code>site()</code>を使用すると<code>BaseConfig</code>を参照する。つまり<code>AddrSize</code>は<code>0x100 * (256/8)</code>になるはずだ。</li>
</ul>
<pre><code class="scala">class Default2Config extends Config(
  new BaseConfig ++
  new Bus128BitConfig ++ new IfuNotConnectConfig
)
class BaseConfig extends Config((site, here, up) =&gt; {
  case BusWidthBytes =&gt; 256 / 8
})

class Bus128BitConfig extends Config((site, here, up) =&gt; {
  case BusWidthBytes =&gt; 128 / 8
  case AddrSize =&gt; 0x100 * here(BusWidthBytes)
})
// TLRAM configured with Bus128BitConfig, with a 12-bit bus width
module TLRAM(
  input          clock,
  input          reset,
  input          auto_in_a_valid,
  input  [2:0]   auto_in_a_bits_opcode,
  input  [12:0]  auto_in_a_bits_address,
  input  [255:0] auto_in_a_bits_data,
  output         auto_in_d_valid,
  output [2:0]   auto_in_d_bits_opcode,
  output [255:0] auto_in_d_bits_data
);
</code></pre>

<ul>
<li>The case of using <code>up()</code>: In the following, two modules, <code>Adder()</code> and <code>Mul()</code>, are defined. The number of input/output bits is defined by <code>p(BitWidth)</code>. We consider the problem of what to do if we want to define completely different bit widths for <code>Adder()</code> and <code>Mul()</code>.</li>
</ul>
<pre><code class="scala">class Adder()(implicit p: Parameters) extends Module {
  val bitwidth = p(BitWidth)
  val io = IO(new Bundle{
    val a = Input(SInt(bitwidth.W))
    val b = Input(SInt(bitwidth.W))
    val c = Output(SInt(bitwidth.W))
  })

  io.c := io.a + io.b
}

class Mul()(implicit p: Parameters) extends Module {
  val bitwidth = p(BitWidth)
  val io = IO(new Bundle{
    val a = Input(SInt(bitwidth.W))
    val b = Input(SInt(bitwidth.W))
    val c = Output(SInt((bitwidth * 2).W))
  })

  io.c := io.a * io.b
}
</code></pre>

<p>At this time, the parameters of <code>Adder()</code> and <code>Mul()</code> are defined as follows. <code>Adder()</code> is assumed to be instantiated with 64 bits, and <code>Mul()</code> with 128 bits input bit width.</p>
<pre><code class="scala">case object AdderBitWidth extends Field[Int]
case object MulBitWidth extends Field[Int]

class DefaultConfig() extends Config((site, here, up) =&gt; {
  case AdderBitWidth =&gt; 64
  case MulBitWidth =&gt; 128
})
</code></pre>

<p>We override the parameters of <code>Adder()</code> and <code>Mul()</code> when we instantiate them, but we have to define and pass <code>adder_param</code> and <code>mul_param</code> anew.</p>
<pre><code class="scala">  val Adder_mod = Module(new Adder()(adder_params))
  Adder_mod.io.a := io.a
  Adder_mod.io.b := io.b
  io.Adder_c := Adder_mod.io.c

  val mul_mod = Module(new Mul()(mul_params))
  mul_mod.io.a := io.a
  mul_mod.io.b := io.b
  io.mul_c := mul_mod.io.c
</code></pre>

<p>Here, <code>adder_params</code> is inherited from the above <code>DefaultConfig</code>, while the <code>BitWidth</code> parameter is inherited from the parameter used in the previous <code>DefaultConfig</code>. Use <code>up()</code> at this time. This will create:</p>
<pre><code class="scala">  val adder_params = p.alter((site, here, up) =&gt; {
    case BitWidth =&gt; up(AdderBitWidth)
  })

  val mul_params = p.alter((site, here, up) =&gt; {
    case BitWidth =&gt; up(MulBitWidth)
  })
</code></pre>

<p>The <code>BitWidth</code> of <code>adder_params</code> will inherit the <code>AdderBitWidth</code> of <code>DefaultConfig</code>, and the <code>BitWidth</code> of <code>mul_params</code> will inherit the <code>MulBitWidth</code> of <code>DefaultConfig</code>. This makes it possible to inherit different parameters for the same <code>BitWidth</code> parameter.</p>
<p>The results are as follows: the input bit width of <code>Adder</code> is 64 bits, inherited from <code>AddrBitWidth</code>, and the input bit width of <code>Mul</code> is 128 bits, inherited from <code>MulBitWidth</code>.</p>
<pre><code class="verilog">module Adder(
  input  [63:0] io_a,
  input  [63:0] io_b,
  output [63:0] io_c
);
  assign io_c = $signed(io_a) + $signed(io_b); // @[up_example.scala 48:8]
endmodule
module Mul(
  input  [127:0] io_a,
  input  [127:0] io_b,
  output [255:0] io_c
);
  assign io_c = $signed(io_a) * $signed(io_b); // @[up_example.scala 59:8]
endmodule
</code></pre>

<h1 id="summary">Summary</h1>
<ul>
<li>Chisel usage points → Network part, not in the core. The part where flexibility is required.</li>
<li>Using Diplomacy to connect to the bus network of your own CPU</li>
<li>The bus part of Rocket-Chip is built with a lot of Diplomacy bus configuration.</li>
<li>More flexible parameterization with <code>Config</code>/<code>Parameter</code>.</li>
</ul>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../diplomacy_more_more_deep_dive/" title="ハードウェア記述言語Chiselを<span style="color: red">もっともっと</span>活用するためのDiplomacy概説" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                ハードウェア記述言語Chiselを<span style="color: red">もっともっと</span>活用するためのDiplomacy概説
              </span>
            </div>
          </a>
        
        
          <a href="../memo/" title="Chisel v.s. Verilog" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Chisel v.s. Verilog
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.d9aa80ab.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
    
  </body>
</html>