



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.0.2">
    
    
      
        <title>ハードウェア記述言語Chiselを<span style="color: red">もっともっと</span>活用するためのDiplomacy概説 - FPGA開発日記 カテゴリ別記事インデックス</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.982221ab.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.224b79ff.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
      <script src="../../assets/javascripts/modernizr.1f0bcf2b.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#chiseldiplomacy" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="FPGA開発日記 カテゴリ別記事インデックス" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              FPGA開発日記 カテゴリ別記事インデックス
            </span>
            <span class="md-header-nav__topic">
              ハードウェア記述言語Chiselを<span style="color: red">もっともっと</span>活用するためのDiplomacy概説
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="FPGA開発日記 カテゴリ別記事インデックス" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    FPGA開発日記 カテゴリ別記事インデックス
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../30os/" title="オペレーティングシステム" class="md-nav__link">
      オペレーティングシステム
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../cpu/" title="CPU" class="md-nav__link">
      CPU
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../dsl_ruby/" title="DSLでビルドツールを自作する" class="md-nav__link">
      DSLでビルドツールを自作する
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../gpgpu/" title="GPGPU 記事一覧" class="md-nav__link">
      GPGPU 記事一覧
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../isca_2019/" title="Isca 2019" class="md-nav__link">
      Isca 2019
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../llvm/" title="LLVM" class="md-nav__link">
      LLVM
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../lowrisc_llvm/" title="RISC-V LLVMバックエンドのステップバイステップガイド" class="md-nav__link">
      RISC-V LLVMバックエンドのステップバイステップガイド
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../machine_learning/" title="機械学習 / TensorFlow" class="md-nav__link">
      機械学習 / TensorFlow
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../mastering_bitcoin/" title="Bitcoin 記事一覧" class="md-nav__link">
      Bitcoin 記事一覧
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../qemu/" title="QEMU" class="md-nav__link">
      QEMU
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../quantum_computing/" title="量子コンピュータ / Q# 記事一覧" class="md-nav__link">
      量子コンピュータ / Q# 記事一覧
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../riscv/" title="RISC-V" class="md-nav__link">
      RISC-V
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../rust/" title="Rust" class="md-nav__link">
      Rust
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../vivado_hls/" title="Vivado-HLS" class="md-nav__link">
      Vivado-HLS
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../zero_deep_3/" title="ゼロから作るDeep Learning ③ のPython実装をRubyで作り直してみる" class="md-nav__link">
      ゼロから作るDeep Learning ③ のPython実装をRubyで作り直してみる
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-17" type="checkbox" id="nav-17" checked>
    
    <label class="md-nav__link" for="nav-17">
      Chisel diplomacy
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-17">
        Chisel diplomacy
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../chisel_basic/" title="Chisel basic" class="md-nav__link">
      Chisel basic
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../chisel_tilelink/" title="9. TileLinkとDiplomacyリファレンス" class="md-nav__link">
      9. TileLinkとDiplomacyリファレンス
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
    <a href="./" title="ハードウェア記述言語Chiselを<span style="color: red">もっともっと</span>活用するためのDiplomacy概説" class="md-nav__link md-nav__link--active">
      ハードウェア記述言語Chiselを<span style="color: red">もっともっと</span>活用するためのDiplomacy概説
    </a>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../memo/" title="Chisel v.s. Verilog" class="md-nav__link">
      Chisel v.s. Verilog
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-18" type="checkbox" id="nav-18">
    
    <label class="md-nav__link" for="nav-18">
      Cq
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-18">
        Cq
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../cq/hifive_unleashed/" title="【供養】 CQ出版インターフェース2019年オープンソースRISC-V特集時にボツとなったHiFive Unleashed特集原稿" class="md-nav__link">
      【供養】 CQ出版インターフェース2019年オープンソースRISC-V特集時にボツとなったHiFive Unleashed特集原稿
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="chiseldiplomacy">ハードウェア記述言語Chiselを<span style="color: red">もっともっと</span>活用するためのDiplomacy概説</h1>
<ul>
<li>発表者：msyksphinz (FPGA開発日記著者)</li>
<li>@msyksphinz_dev</li>
<li><a href="https://msyksphinz.hatenablog.com">https://msyksphinz.hatenablog.com</a></li>
</ul>
<h1 id="chisel">Chisel使ってますか？</h1>
<p><img src="https://community.cadence.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-01-06/Screen-Shot-2016_2D00_12_2D00_01-at-1.14.14-PM.jpg" alt="RISC-V 5th Workshop Highlights - Breakfast Bytes - Cadence Blogs - Cadence  Community" style="zoom:33%;" /></p>
<ul>
<li>Scalaをベースとしたハードウェア構築言語.</li>
<li>高位合成言語ではない</li>
<li>SiFiveのRISC-V IPで採用されている</li>
<li>Rocket-Chip : <a href="https://github.com/chipsalliance/rocket-chip">https://github.com/chipsalliance/rocket-chip</a></li>
<li>
<p>BOOM : <a href="https://github.com/riscv-boom/riscv-boom">https://github.com/riscv-boom/riscv-boom</a></p>
</li>
<li>
<p>Chiselの基礎 : 「Chiselを始めたい人に読んで欲しい本」 <a href="https://nextpublishing.jp/book/12162.html">https://nextpublishing.jp/book/12162.html</a></p>
</li>
</ul>
<h1 id="chiselverilog">ChiselがVerilogを生成するまで</h1>
<ul>
<li>
<p>ChiselはScalaのDSLなので、Chisel CompilerはScalaで記述してある</p>
</li>
<li>
<p>Chisel Compilerは<span style="color:red">FIR (Flexible Interpretation Representation)</span>と呼ばれる中間言語を生成する</p>
</li>
<li>
<p>FIRはScalaの文法と関係ない</p>
</li>
<li>
<p>FIRをFIRRTLという変換器を使ってVerilogに変換する</p>
</li>
<li>
<p>FIRRTLもScalaで記述してある (FIRはScalaのDSLではないので、Scalaで作る必要はないと思うけど...)[^circt]</p>
</li>
</ul>
<pre><code class="flow">st=&gt;inputoutput: Chisel(Scala)
op1=&gt;subroutine: Chisel Compiler
io=&gt;inputoutput: FIR(IR)
sub1=&gt;subroutine: FIRRTL Compiler
cond=&gt;inputoutput: Verilog

st(right)-&gt;op1(right)-&gt;io(right)-&gt;sub1(right)-&gt;cond
cond(yes)-&gt;e
cond(no)-&gt;op1
</code></pre>

<p>[^circt]: FIRRTLの置き換えとして、Chris Lattner主導でLLVMとMLIRを使用した「CIRCT」というツールが開発されている <a href="https://github.com/llvm/circt">https://github.com/llvm/circt</a></p>
<h1 id="chisel_1">Chiselの何が良いのか？</h1>
<ul>
<li>Scalaというソフトウェア記述言語の機能が使える</li>
<li>→ この結果Verilogエンジニアには<span style="color:red">一見理解できない意味不明な記述が時々登場する</span></li>
</ul>
<h2 id="fir">例：FIRフィルタ</h2>
<p><img alt="fir_filter.PNG" src="../fir_filter.PNG" /></p>
<h3 id="1">解答例1. 初心者が書いた</h3>
<pre><code class="scala">// stage size is temporary 4
class My4ElementFir(b0: Int, b1: Int, b2: Int, b3: Int) extends Module {
  val io = IO(new Bundle {
    val in = Input(UInt(8.W))
    val out = Output(UInt(8.W))
  })

  val x_n1 = RegNext(io.in, 0.U)
  val x_n2 = RegNext(x_n1, 0.U)
  val x_n3 = RegNext(x_n2, 0.U)
  io.out := io.in * b0.U(8.W) + x_n1 * b1.U(8.W) +
             x_n2 * b2.U(8.W) + x_n3 * b3.U(8.W)
}
</code></pre>

<h3 id="2-msyksphinz">解答例2. 私(@msyksphinz)が書いた</h3>
<p><span style="color:red">ほぼVerilogじゃねーか！</span></p>
<pre><code class="scala">class MyManyDynamicElementVecFir(length: Int) extends Module {
  val io = IO(new Bundle {
    val in = Input(UInt(8.W))
    val valid = Input(Bool())
    val out = Output(UInt(8.W))
    val consts = Input(Vec(length, UInt(8.W)))
  })

  val taps = Reg(Vec(length, UInt(8.W)));
  for (i &lt;- 0 until length) {
    if (i == 0) { when(io.valid) { taps(i) := io.in     } }
    else        { when(io.valid) { taps(i) := taps(i-1) } }
  }
  val w_fir_res = Wire(Vec(length, UInt(8.W)))
  for (i &lt;- 0 until length) {
    val w_tap_mul = Wire(UInt(8.W))
    w_tap_mul := taps(i) * io.consts(i)
    if (i == 0) { w_fir_res(i) := 0.U }
    else        { w_fir_res(i) := w_tap_mul + w_fir_res(i-1) }
  }
  io.out := w_fir_res(length-1)
}
</code></pre>

<h2 id="3-chisel">解答例3. 頭のおかしなChiselエンジニアが書いた</h2>
<ul>
<li><span style="color:red">一見じゃ理解できねーぞ？</span></li>
</ul>
<p><a href="https://github.com/freechipsproject/chisel-bootcamp/blob/master/2.5_exercise.ipynb">https://github.com/freechipsproject/chisel-bootcamp/blob/master/2.5_exercise.ipynb</a></p>
<pre><code class="scala">class MyManyDynamicElementVecFir(length: Int) extends Module {
  val io = IO(new Bundle {
    val in = Input(UInt(8.W))
    val valid = Input(Bool())
    val out = Output(UInt(8.W))
    val consts = Input(Vec(length, UInt(8.W)))
  })

  val taps = Seq(io.in) ++ Seq.fill(io.consts.length - 1)(RegInit(0.U(8.W)))
  taps.zip(taps.tail).foreach { case (a, b) =&gt; when (io.valid) { b := a } }

  io.out := taps.zip(io.consts).map { case (a, b) =&gt; a * b }.reduce(_ + _)
</code></pre>

<h1 id="chiselscala">閑話休題：なぜChiselは<span style="color:green">Scala</span>を選んだか？</h1>
<ul>
<li>ウワサ：UCBでChiselの初期版を作った時、<span style="color:red">Ruby</span>を使ったらコンパイルが劇遅であきらめた</li>
<li>
<p>まあScalaのコンパイルも速くないと思うけどね</p>
</li>
<li>
<p>Scalaの特徴：頭がおかしいくらい演算子のオーバライドができる</p>
</li>
<li>例1 : 通常のChisel記述での<code>A := B</code>と、TileLink内における<code>A := B</code>は意味が違う</li>
</ul>
<pre><code class="scala"> /** Connect this $coll to that $coll mono-directionally and element-wise.
    *
    * This uses the [[MonoConnect]] algorithm.
    *
    * @param that the $coll to connect to
    * @group Connect
    */
  final def := (that: Data)(implicit sourceInfo: SourceInfo, connectionCompileOptions: CompileOptions): Unit = this.connect(that)(sourceInfo, connectionCompileOptions) // scalastyle:ignore line.size.limit
</code></pre>

<ul>
<li>例2：頭のおかしなAXIバス接続 (<code>src/main/scala/subsystem/Ports.scala</code>)</li>
</ul>
<pre><code class="scala"> mbus.coupleTo(s&quot;memory_controller_port_named_$portName&quot;) {
    (memAXI4Node
      :*= AXI4UserYanker()
      :*= AXI4IdIndexer(idBits)
      :*= TLToAXI4()
      :*= TLWidthWidget(mbus.beatBytes)
      :*= _)
  }
</code></pre>

<h1 id="chisel_2">本題に戻って：なぜChiselを使うの？</h1>
<p><img alt="msyksphinz_chisel_tweet.PNG" src="../msyksphinz_chisel_tweet.PNG" /></p>
<h4 id="verilog"><span style="color:red">暴論：普通にハードウェア作りたいなら、Verilogの方が便利に決まっている！！！！</span></h4>
<ul>
<li>テストが書きやすい？ → UVMの方が高機能じゃない？</li>
<li>エラー検出が優れている？ → 一般的な書き間違えのエラーならシミュレータで十分検出できる</li>
<li>私から見えているクラスタのChiselを使うための「<span style="color:red">言い訳</span>」</li>
<li><span style="color:blue">Rocket-Chipが使っているからやむを得ず</span></li>
<li><span style="color:blue">新しい言語で何かを書いて皆に「すごい」って言ってほしい</span></li>
</ul>
<h4 id="chisel_3"><span style="color:red">じゃあChiselの使いどころってどこよ？</span></h4>
<ul>
<li><span style="color:blue">技術の進化が、ハードウェア設計の周期をはるかに上回ってきた</span></li>
<li>ハードウェアエンジニア、技術の進化に追いついてきている？</li>
<li>チップ作るのに2～3年かかる。これで最先端AIチップ作れますか？</li>
<li>DSAの時代、<span style="color:red">少量多品種</span>で作り上げなければならない</li>
<li>(関係ないけど)少量多品種で弱者が簡単にチップを起こす時代が来るべき</li>
<li>ハードウェアの「複雑性」どのように管理する？</li>
</ul>
<p><img alt="hardware_difficulty" src="../hardware_difficulty.PNG" /></p>
<h1 id="chiseldiplomacy_1">Chiselの使いどころ一例：<span style="color:red">Diplomacy</span></h1>
<ul>
<li>Parameter Negotiation Framework for generating parameterized protocol implementation.</li>
</ul>
<p><img alt="diplomacy.PNG" src="../diplomacy.PNG" /></p>
<h1 id="diplomacy">Diplomacyはどこから来たの？</h1>
<ul>
<li>Andrew Watermanの博士論文：</li>
<li>Design of the RISC-V Instruction Set Architecture</li>
<li><a href="https://people.eecs.berkeley.edu/~krste/papers/EECS-2016-1.pdf">https://people.eecs.berkeley.edu/~krste/papers/EECS-2016-1.pdf</a></li>
<li>Yunsup Leeの博士論文：</li>
<li>Decoupled Vector-Fetch Architecture with a Scalarizing Compiler</li>
<li><a href="https://people.eecs.berkeley.edu/~krste/papers/EECS-2016-117.pdf">https://people.eecs.berkeley.edu/~krste/papers/EECS-2016-117.pdf</a></li>
<li>Henry Cookの博士論文：</li>
<li><span style="color:red">Productive Design of Extensible On-Chip Memory Hierarchies</span></li>
<li>Diplomacyの基本的なアイデアがこの論文に書いてある</li>
<li><a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-89.pdf">https://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-89.pdf</a></li>
</ul>
<h1 id="diplomacy_1">Diplomacyの実現したいこと</h1>
<ul>
<li>一つのデザインを使って柔軟なコンフィグレーションを実現する</li>
<li>一つのデザインから</li>
<li>複数のCPUコンフィグレーション (RV64 / RV32)</li>
<li>複数のバス構成・キャッシュ構成<ul>
<li>コア数・バス幅、キャッシュサイズ、SoC構成</li>
</ul>
</li>
</ul>
<p><img alt="image-20201130123338375" src="../diplomacy_SoC_variation.PNG" /></p>
<h3 id="sifivecore-ip-generator">一つの実現例：SiFiveのCore IP Generator</h3>
<ul>
<li><a href="https://scs.sifive.com/core-designer/">https://scs.sifive.com/core-designer/</a></li>
</ul>
<p><img alt="coreip_generator.PNG" src="../coreip_generator.PNG" /></p>
<h1 id="chisel-diplomacyintellij-idea">閑話休題：Chisel + Diplomacyを使って開発したいならIntelliJ IDEAを使おう</h1>
<p><span style="color:red">マジでAuto Completionの機能が無いと死ぬ。</span></p>
<p><img alt="image-20201212012922069" src="../intellij_auto_completion.PNG" /></p>
<h1 id="diplomacytilelink">誤解：DiplomacyはTileLinkを使わないと使えないの？</h1>
<p>そんなことはない。DiplomacyはChiselのライブラリなのでTileLinkを使わなくても使える。</p>
<h2 id="diplomacymultiple-inputsadder">例: Diplomacyで繋げたMultiple InputsのAdder</h2>
<p><img alt="multiple_inputs_adder.PNG" src="../multiple_inputs_adder.PNG" /></p>
<p>ここで読み解かなければならないのは以下の3つのモジュール：</p>
<ul>
<li><code>AdderDriver</code> : 加算器に対してランダム値を送信するためのドライバー</li>
<li><code>AdderNode</code> : 加算器本体。2つ以上の<code>AdderDriver</code>が接続されその値をすべて足し合わせ、結果を出力する</li>
<li><code>AdderMonitor</code> : モニタ。<code>AdderDriver</code>の発信した値と<code>AdderNode</code>が生成した加算結果を突き合わせ、答え合わせをする機能を持つ</li>
</ul>
<h3 id="adderdriver">AdderDriver</h3>
<p>加算器に対してランダム値を送信するためのドライバー。<code>AdderDriver</code>を読み解くためのポイント：</p>
<ol>
<li><span style="color:red"><code>val node = new AdderDriverNode</code> って何？</span></li>
<li><span style="color:red"><code>new LazyModuleImp(this)</code>って何？</span></li>
</ol>
<pre><code class="scala">// class モジュール名 extends LazyModule はDiplomacy経由で接続するためのモジュールだと思ってもらえれば.
class AdderDriver(width: Int, numOutputs: Int)(implicit p: Parameters) extends LazyModule {
    // 1. AdderDriverNodeとは何か、そもそも&quot;node&quot;はどのような役割を持つのか？
    val node = new AdderDriverNode(Seq.fill(numOutputs)(DownwardParam(width)))

    // 2. LazyModuleImp()とは何か、Diplomacy内でどのような役割を持つのか
    lazy val module = new LazyModuleImp(this) {
        ...
        // drive signals
        node.out.foreach { case (addend, _) =&gt; addend := randomAddend }
    }
}

// AdderDriverNode は SourceNode クラスを継承して作成されたもの
class AdderDriverNode(widths: Seq[DownwardParam])(implicit valName: ValName)
  extends SourceNode(AdderNodeImp)(widths)
</code></pre>

<ul>
<li><code>SourceNode</code>はマスターとなるノードに使用する。</li>
<li><code>SinkNode</code>はスレーブとなるノードに使用する。</li>
<li><code>AdapterNode</code>は複数のマスターと複数のスレーブを接続する。マスターとスレーブの数は同一でなければならない。</li>
<li><code>NexusNode</code>は複数のマスターと複数のスレーブを接続する。マスターとスレーブの数は同一でなくても良い。</li>
</ul>
<h4 id="1-node">1. node : モジュール間を接続するためのもの</h4>
<p><code>node</code>はDiplomacyにおいてモジュール間で通信を行うための通信ポート。<code>node</code>間で様々なパラメータをやり取りし、パラメータの調停を行う役割を持つ。</p>
<p><code>node</code>には2つの重要な要素がある。</p>
<ul>
<li>
<p><code>bundle</code> : Diplomacyによって接続されるI/Oポートが含まれている。今回の場合はランダム値を送信するための信号が一束入っているだけ</p>
</li>
<li>
<p><code>edge</code> : Diplomacyのノード間を接続するためのパラメータ群が入っている。これらのパラメータをノード間で通信し最終的なノード間パラメータ調整（Diplomacy）を行う。</p>
</li>
</ul>
<pre><code class="scala">object AdderNodeImp extends SimpleNodeImp[DownwardParam, UpwardParam, EdgeParam, UInt] {
  // edge : Diplomacyのノード間を接続するためのパラメータ群が入っている。
  def edge(pd: DownwardParam, pu: UpwardParam, p: Parameters, sourceInfo: SourceInfo) = {
    if (pd.width &lt; pu.width) EdgeParam(pd.width) else EdgeParam(pu.width)
  }

  // Diplomacyによって接続されるI/Oポートが含まれている。
  // UInt(e.width.W) : eはEdgeParam,つまりエッジのパラメータ
  def bundle(e: EdgeParam) = UInt(e.width.W)

  def render(e: EdgeParam) = RenderedEdge(&quot;blue&quot;, s&quot;width = ${e.width}&quot;)
}
</code></pre>

<h4 id="2-lazymoduleimp-node">2. <code>LazyModuleImp</code> : nodeの情報をもとに回路を実装する部分</h4>
<p><code>node</code>とのデータ通信をしつつ実際の処理を行うためのデジタル処理部。</p>
<pre><code class="scala">  val node = new AdderDriverNode(Seq.fill(numOutputs)(DownwardParam(width)))

  lazy val module = new LazyModuleImp(this) {
    // すべてのノードのエッジからビット幅情報を取り出す
    val negotiatedWidths = node.edges.out.map(_.width)
    // すべてのノード間接続線のビット数が一致するか？
    require(negotiatedWidths.forall(_ == negotiatedWidths.head), &quot;outputs must all have agreed on same width&quot;)

    // いつぃているならば、先頭ノードの情報を使用する (まあどのノードの情報を使っても同じだけど)
    val finalWidth = negotiatedWidths.head

    // FibonacciLFSRモジュールにより乱数を生成
    val randomAddend = FibonacciLFSR.maxPeriod(finalWidth)

    // 乱数をすべての出力ノードに対して送り込む
    node.out.foreach { case (addend, _) =&gt; addend := randomAddend }
  }
</code></pre>

<h3 id="diplomacyyed">Diplomacyを使う場合は、yEdを使ってノードグラフ図を確認しよう</h3>
<p><img alt="yed_adder_node_graph.PNG" src="../yed_adder_node_graph.PNG" /></p>
<div align="center">図. yEdによりAdderグラフを生成した図</div>

<ul>
<li>もっと複雑な例：Freedom-SoCで4コア構成作成時のノード接続関係図</li>
</ul>
<p><img alt="freedom_diplomacy_node.PNG" src="../freedom_diplomacy_node.PNG" /></p>
<div align="center">図. freedom SoC ノード接続関係図</div>

<h1 id="tilelinkcpu">TileLinkを使った自作CPU＋多彩なバス接続を実現</h1>
<h3 id="cpu">ちょっと自作CPUしてみる</h3>
<ul>
<li>Chiselを使って自作CPUして、それにTileLinkを接続して簡単なマルチコアシステムを作ってみる。</li>
</ul>
<h4 id="cpu-rv645">作ったCPUコア: RV64の簡単な5段パイプライン</h4>
<p>まともに検証していないけどとりあえず<code>riscv-tests</code>程度は動くCPUコアを作った。</p>
<p><a href="https://github.com/msyksphinz-self/chisel-soc/tree/main/src/main/scala/core">https://github.com/msyksphinz-self/chisel-soc/tree/main/src/main/scala/core</a></p>
<p><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/m/msyksphinz/20181224/20181224131915.png" alt="Chiselを使って波形を全く使わずにRISC-Vパイプラインプロセッサを設計した - FPGA開発日記" style="zoom:50%;" /></p>
<ul>
<li>フェッチバス・データバスは非常に単純なもの（非TileLink / 非AXIバス）</li>
</ul>
<p><a href="https://github.com/msyksphinz-self/chisel-soc/blob/main/src/main/scala/core/cpu_bus.scala#L17">https://github.com/msyksphinz-self/chisel-soc/blob/main/src/main/scala/core/cpu_bus.scala#L17</a> (<code>InstBus</code>へのリンク)</p>
<p><a href="https://github.com/msyksphinz-self/chisel-soc/blob/main/src/main/scala/core/cpu_bus.scala#L30">https://github.com/msyksphinz-self/chisel-soc/blob/main/src/main/scala/core/cpu_bus.scala#L30</a> (<code>DataBus</code>へのリンク)</p>
<h3 id="cputilelinksoc">自作CPUをどのようにしてTileLinkに組み込んでSoCを構築するか？</h3>
<ol>
<li>自作CPUをLazyModuleでラップする</li>
<li><code>TileLink</code>のノードを定義する</li>
<li>TileLinkのノードと自作CPUのノードを接続する</li>
</ol>
<p><img alt="image-20201212151257774" src="../cpu_configuration.PNG" /></p>
<div align="center">図. 自作CPUのインタフェース構成</div>

<ul>
<li>TileLinkのノードは2つ用意している。</li>
<li>命令フェッチ用</li>
<li>データアクセス用</li>
<li>どちらもTileLinkだが、自作CPUは独自バスプロトコルなので無理やり置き換えている。</li>
<li>これで、<code>CoreTop</code>モジュールはTileLinkのインタフェースを2つ持ったモジュールに置き換わる</li>
</ul>
<pre><code class="scala">    // TileLinkで定義した命令・データバスのClientNodeを内部に引っ張ってくる
    val (inst_out, inst_edge) = inst_node.out(0)
    val (data_out, data_edge) = data_node.out(0)
    val baseEnd = 0
    val (sizeEnd, sizeOff) = (inst_edge.bundle.sizeBits + baseEnd, baseEnd)
    val (sourceEnd, sourceOff) = (inst_edge.bundle.sourceBits + sizeEnd, sizeEnd)
    val beatBytes = inst_edge.bundle.dataBits

    // 自作CPUのインスタンス定義
    val cpu = Module(new Cpu(conf, hartid))

    // TileLinkのフェッチポートの信号と、自作CPUのフェッチポート(独自プロトコル)を接続
    inst_out.a.valid := cpu.io.inst_bus.req
    inst_out.a.bits.address := cpu.io.inst_bus.addr
    inst_out.a.bits.opcode := TLMessages.Get
    ...
    cpu.io.inst_bus.ready := inst_out.a.ready
    cpu.io.inst_bus.ack := inst_out.d.valid
    cpu.io.inst_bus.rddata := inst_out.d.bits.data.asSInt

    // TileLinkのデータアクセスポートの信号と、自作CPUのデータアクセスポート(独自プロトコル)を接続
    data_out.a.valid := cpu.io.data_bus.req
    data_out.a.bits.address := cpu.io.data_bus.addr
    data_out.a.bits.opcode := TLMessages.Get
    ...
    cpu.io.data_bus.ack := data_out.d.valid
    cpu.io.data_bus.rddata := data_out.d.bits.data.asSInt
</code></pre>

<h3 id="tilelinkcoretopsoc">TileLinkモジュールを持っCoreTopを使ってSoCを作る</h3>
<p><code>CoreTop</code>とメモリモジュールを持つ<code>CoreComplex</code>モジュールを作成してこれらを接続する。</p>
<pre><code class="scala">class core_complex[Conf &lt;: RVConfig]
  (conf: Conf, numCores: Int, ramBeatBytes: Int, txns: Int)(implicit p: Parameters)
  extends LazyModule {
  // 外部からメモリにデータアクセスするためのデータローダ
  val loader = LazyModule(new loader(&quot;loader&quot;))

  // CPUコア(numCore分だけ複数個インスタンス化する)
  val core   = Seq.tabulate(numCores) { case i =&gt; LazyModule(new CoreTop(conf, i, &quot;core&quot; + i.toString)) }
  // TileLinkのクロスバ
  val xbar   = LazyModule(new TLXbar)
  // TileLinkインタフェースを持つメモリ
  val memory = LazyModule(new TLRAM(AddressSet(0x80000000L, 0x0ffff), beatBytes = ramBeatBytes))

  // クロスバにデータローダを接続する
  xbar.node := loader.node
  core.foreach { case (core) =&gt; {
    // クラスバにCPUコアの命令フェッチポートとデータポートを接続する
    xbar.node := TLDelayer(0.1) := core.inst_node
    xbar.node := TLDelayer(0.1) := core.data_node
  }
  }
  // クロスバをメモリに接続する
  memory.node := xbar.node

</code></pre>

<p><img alt="image-20201212152847526" src="../core_complex_core1.PNG" /></p>
<div align="center">図. 自作CPUをTileLinkを通じてメモリに接続し、簡単なSoCを構成する</div>

<h3 id="numcores1"><code>numCores</code>を&gt;1にして簡単にマルチコア構成を実現</h3>
<p>上記のChiselの記述ならば、簡単にマルチコアにできる。<code>nCores</code>に2, 3, ... を設定するだけで自動的にクロスバに複数のCPUが接続されるようになる。</p>
<p><img alt="image-20201212153430326" src="../core_complex_coreN.PNG" /></p>
<div align="center">図. 自作CPUをTileLinkを通じてメモリに接続する。コア数=4の場合</div>

<ul>
<li>簡単にシミュレーションしてみた例。とりあえず4コアが同時にリクエストしても上手くメモリアクセスをArbitrationできている。</li>
</ul>
<p><img alt="multicore_memory_access" src="../multicore_memory_access.PNG" /></p>
<div align="center">図. 4コア構成でのRTLシミュレーションの様子</div>

<ul>
<li>4コア構成にした場合のDiplomacyノード構成の例</li>
</ul>
<p><img alt="multicore_diplomacy_node.PNG" src="../multicore_diplomacy_node.PNG" /></p>
<div align="center">図. 4コア構成でのDiplomacy接続関係図</div>

<h1 id="rockettile">RocketTileを例にバスの繋げ方を学ぼう</h1>
<ul>
<li>RISC-V の CPU実装代表格：Rocket-Chip <a href="https://github.com/chipsalliance/rocket-chip">https://github.com/chipsalliance/rocket-chip</a></li>
</ul>
<h3 id="rocket-chip-generatorgenerator">Rocket-Chip Generator：なぜ「Generator」と名前が付けられているのか分かりますか？</h3>
<ul>
<li>Rocket-Chipはデザインだけでなく、デザイン間の調整を行うためのDiplomacyや、Chisel実装・FIRRTL実装自体も含まれている総合パッケージとなっている。</li>
<li>Scalaによる実装だけでなくハードウェアを生成するためのすべてのエンジンを含んでいるため、「Generator」と呼ばれている。</li>
</ul>
<h2 id="rocket-chipdefaultconfigdiplomacy">Rocket-Chipの<code>DefaultConfig</code>のDiplomacy構成を見てみよう</h2>
<p>Rocket-Chipのバス接続は基本的にTileLinkとDiplomacyを使って構成されている。</p>
<p><img alt="rocket_chip_diplomacy_node.PNG" src="../rocket_chip_diplomacy_node.PNG" /></p>
<p>もう少し噛み砕いてみる。</p>
<p>バス接続部を見てみる。</p>
<h2 id="rockettilediplomacy">RocketTileで学ぶDiplomacyによるデバイスの接続</h2>
<ul>
<li>RocketTile : RocketChipとDCacheなどの基本的な構成をすべて含んだ基本的なCPUコア1要素。</li>
<li>CPUベンダの中では、"CoreComplex"とも言ったりするかなあ... なんで"Core Complex"って言うんだろう？良く分からん。</li>
</ul>
<h3 id="rocket-chip">Rocket-Chipによる(簡単な)メモリマップ</h3>
<table>
<thead>
<tr>
<th>Start Address</th>
<th>Stop Address</th>
<th>Attributes</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0000_0000</td>
<td>0x0000_1000</td>
<td>ARWX</td>
<td>debug-controller@0</td>
</tr>
<tr>
<td>0x0000_3000</td>
<td>0x0000_4000</td>
<td>ARWX</td>
<td>error-device@3000</td>
</tr>
<tr>
<td>0x0001_0000</td>
<td>0x0002_0000</td>
<td>RX</td>
<td>rom@10000</td>
</tr>
<tr>
<td>0x0200_0000</td>
<td>0x0200_1000</td>
<td>ARW</td>
<td>clint@2000000</td>
</tr>
<tr>
<td>0x0c00_0000</td>
<td>0x1000_0000</td>
<td>ARW</td>
<td>interrupt_controller</td>
</tr>
<tr>
<td>0x6000_0000</td>
<td>0x8000_0000</td>
<td>RWX</td>
<td>mmio-port-axi4@60000000</td>
</tr>
<tr>
<td>0x8000_0000</td>
<td>0x9000_0000</td>
<td>RWXC</td>
<td>memory@8000_0000</td>
</tr>
</tbody>
</table>
<h2 id="rockettile_1">RocketTileの中身</h2>
<pre><code class="verilog">module RocketTile( // @[:freechips.rocketchip.system.DefaultConfig.fir@200426.2]

  TLXbar_8 tlMasterXbar ();

  IntXbar_4 intXbar ();

  DCache dcache ();

  Frontend frontend ();

  TLBuffer_9 buffer ();

  IntSyncCrossingSink intsink ();

  IntSyncCrossingSink_1 intsink_1 ();

  IntSyncCrossingSink_2 intsink_2 ();

  IntSyncCrossingSink_2 intsink_3 ();

  FPU fpuOpt ();

  HellaCacheArbiter dcacheArb ();

  PTW ptw ();

  Rocket core ();
</code></pre>

<p>重要な部分を抜粋して図を作ってみた。<span style="color:blue">青がLazyModule</span>、<span style="color:red">赤が通常Module</span>。</p>
<p><img alt="rocket_tile.PNG" src="../rocket_tile.PNG" /></p>
<p>これをScalaから同読み解けばいいのさ？という話で、いくつか例を挙げてどのようにしてノード間が接続されているのか見てみよう。</p>
<ul>
<li><code>RocketTile.scala</code>で当該部分を見てみよう。</li>
</ul>
<pre><code class="scala">class RocketTile private(
      val rocketParams: RocketTileParams,
      crossing: ClockCrossingType,
      lookup: LookupByHartIdImpl,
      q: Parameters,
      logicalTreeNode: LogicalTreeNode)
    extends BaseTile(rocketParams, crossing, lookup, q)
    with SinksExternalInterrupts
    with SourcesExternalNotifications
    with HasLazyRoCC  // implies CanHaveSharedFPU with CanHavePTW with HasHellaCache
    with HasHellaCache
    with HasICacheFrontend
{
/* ... */
    override lazy val module = new RocketTileModuleImp(this)
/* ... */
}
</code></pre>

<ul>
<li><code>RocketTileModuleImp</code>はどのような実装になっているのか？</li>
</ul>
<pre><code class="scala">// &quot;outer&quot; は 上記の RocketTile に相当する
class RocketTileModuleImp(outer: RocketTile) extends BaseTileModuleImp(outer)
    with HasFpuOpt
    with HasLazyRoCCModule
    with HasICacheFrontendModule {
/* ... */
  val core = Module(new Rocket(outer)(outer.p))
/* ... */
  outer.frontend.module.io.cpu &lt;&gt; core.io.imem
  dcachePorts += core.io.dmem // TODO outer.dcachePorts += () =&gt; module.core.io.dmem ??

  /* FPUについてはオプションによっては接続する */
  fpuOpt foreach { fpu =&gt; core.io.fpu &lt;&gt; fpu.io }

  /* DCacheをデータキャッシュのアービタに接続する */
  dcacheArb.io.requestor &lt;&gt; dcachePorts
  ptw.io.requestor &lt;&gt; ptwPorts

</code></pre>

<ul>
<li>FPUを接続する部分（ここはDiplomacyを使っていない）</li>
</ul>
<p><img alt="fpu_diplomacy.PNG" src="../fpu_diplomacy.PNG" /></p>
<ul>
<li>DCacheを接続する部分</li>
</ul>
<p><img alt="image-20201212001639688" src="../dcache_diplomacy.PNG" /></p>
<h2 id="rocket-chipsoc">Rocket-ChipのSoC部分の構成を読み解こう</h2>
<ul>
<li>Rocket-Chip GeneratorでVerilogを生成すると、<code>TestHarness</code>というトップモジュールが生成されるが、これがテスト実行用のモジュールとなる。</li>
<li>これもVerilogの力を借りずすべてChiselから生成されている。</li>
<li><code>src/main/scala/system/TestHarness.scala</code></li>
</ul>
<pre><code class="scala">class TestHarness()(implicit p: Parameters) extends Module {
  val io = new Bundle {
    val success = Bool(OUTPUT)
  }

  val ldut = LazyModule(new ExampleRocketSystem) // ExampleRocketSystemのインスタンス化.
  val dut = Module(ldut.module)  // ExmapleRocketSystemはLazyModuleなので、その内部にある実体をdutとして取り出す

  dut.dontTouchPorts()
  dut.tieOffInterrupts()
  SimAXIMem.connectMem(ldut)        // object SimAXIMemをインスタンス化してldutのメモリポートを接続
  SimAXIMem.connectMMIO(ldut)       // object SimAXIMemをインスタンス化してldutのMMIOポートを接続
  ldut.l2_frontend_bus_axi4.foreach(_.tieoff)   // ldutのフロントエンドポートはTie Zeroする
</code></pre>

<ul>
<li><code>SimAXIMem.connectMem(ldut)</code>の部分を除いてみる</li>
</ul>
<pre><code class="scala">  def connectMem(dut: CanHaveMasterAXI4MemPort)(implicit p: Parameters): Seq[SimAXIMem] = {
    // ExampleRocketSystemのmem_axi4はioポートを示している
    // dut.memAXI4Node.inはLazyModuleのSlavePortノード
    dut.mem_axi4.zip(dut.memAXI4Node.in).map { case (io, (_, edge)) =&gt;
      // 新たにAXI4メモリをインスタンス化する
      // メモリのサイズはAXIノードのedge情報に依存する
      val mem = LazyModule(new SimAXIMem(edge, size = p(ExtMem).get.master.size))
      Module(mem.module).suggestName(&quot;mem&quot;)
      // メモリインスタンスのI/OポートとldutのAXIポートを接続する
      mem.io_axi4.head &lt;&gt; io
      mem
    }
  }
</code></pre>

<ul>
<li>AXI4メモリポートの仕組み (<code>src/main/scala/subsystem/Ports.scala</code>)</li>
</ul>
<pre><code class="scala">/** Adds a port to the system intended to master an AXI4 DRAM controller. */
trait CanHaveMasterAXI4MemPort { this: BaseSubsystem =&gt;
  private val memPortParamsOpt = p(ExtMem)
  private val portName = &quot;axi4&quot;
  private val device = new MemoryDevice
  private val idBits = memPortParamsOpt.map(_.master.idBits).getOrElse(1)
  // AXI4のDiplomacy スレーブノードを作る。
  // なぜスレーブなのかは、内部のTileLink (master) がマスターで、AXI4ノードがスレーブだから
  val memAXI4Node = AXI4SlaveNode(memPortParamsOpt.map({ case MemoryPortParams(memPortParams, nMemoryChannels) =&gt;
    Seq.tabulate(nMemoryChannels) { channel =&gt;
      val base = AddressSet.misaligned(memPortParams.base, memPortParams.size)
      val filter = AddressSet(channel * mbus.blockBytes, ~((nMemoryChannels-1) * mbus.blockBytes))
...
  // mbus (memory bus) に対してノードの接続を行う。
  mbus.coupleTo(s&quot;memory_controller_port_named_$portName&quot;) {
    (memAXI4Node                            // AXIのメモリノード
      :*= AXI4UserYanker()                  // ↑ AXI4プロトコルにUserフィールドを付加する
      :*= AXI4IdIndexer(idBits)             // ↑ AXI4のIDビットを拡張する
      :*= TLToAXI4()                        // ↑ AXI4にプロトコルを変更する
      :*= TLWidthWidget(mbus.beatBytes)     // ↑ mbus(TileLink)のバス幅を変更する
      :*= _)                                // ↑ これはmbusの意味
  }

  val mem_axi4 = InModuleBody { memAXI4Node.makeIOs() }
}
</code></pre>

<ul>
<li>注 : MMIOまで何でメモリに繋がってるの？と思わるかもしれないが、これはテスト環境なので自動的にメモリが接続されている。</li>
</ul>
<p><img alt="image-20201212135420935" src="../TestHarness.PNG" /></p>
<h1 id="config-parameterconfigurable">Config / Parameterを使ったConfigurableなモジュールの作り方</h1>
<h2 id="rocket-chipverilog"><span style="color:blue">モチベーション：Rocket-Chipはなんでこんなに生成できるVerilogのバリエーションが多いの？</span></h2>
<pre><code class="sh">$ make CONFIG=DefaultConfig     # RV64GC構成を生成
$ make CONFIG=RV32Config        # RV32GC構成を生成
$ make CONFIG=DualCoreConfig    # 2コア構成のSoCを生成
$ make CONFIG=RoCCExampleConfig # RoCC (Rocket Custom Coprocessor) 付きの構成を生成
</code></pre>

<h3 id="modularity">各機能がModularityを維持しつつ分割されているから</h3>
<p><img alt="image-20201213122345167" src="../rocket_chip_configurabilty.PNG" /></p>
<div align="center">図. Rocket-Chip + SoCの構成は各モジュールが非常に独立性高く設計されている</div>

<ul>
<li><code>src/main/scala/system/Configs.scala</code></li>
</ul>
<pre><code class="scala">class BaseConfig extends Config(
  new WithDefaultMemPort() ++
  new WithDefaultMMIOPort() ++
  new WithDefaultSlavePort() ++
  new WithTimebase(BigInt(1000000)) ++ // 1 MHz
  new WithDTS(&quot;freechips,rocketchip-unknown&quot;, Nil) ++
  new WithNExtTopInterrupts(2) ++
  new BaseSubsystemConfig()
)

class DefaultConfig extends Config(new WithNBigCores(1) ++ new WithCoherentBusTopology ++ new BaseConfig)
 
class DefaultBufferlessConfig extends Config(new WithBufferlessBroadcastHub ++ new DefaultConfig)
class DefaultSmallConfig extends Config(new WithNSmallCores(1) ++ new WithCoherentBusTopology ++ new BaseConfig)
class DefaultRV32Config extends Config(new WithRV32 ++ new DefaultConfig)
 
class DualBankConfig extends Config(new WithNBanks(2) ++ new DefaultConfig)
class DualCoreConfig extends Config(new WithNBigCores(2) ++ new WithCoherentBusTopology ++ new BaseConfig)
class DualChannelConfig extends Config(new WithNMemoryChannels(2) ++ new DefaultConfig)
class EightChannelConfig extends Config(new WithNMemoryChannels(8) ++ new DefaultConfig)
 
class DualChannelDualBankConfig extends Config(
  new WithNMemoryChannels(2) ++
  new WithNBanks(4) ++ new DefaultConfig)
 
class RoccExampleConfig extends Config(new WithRoccExample ++ new DefaultConfig)
</code></pre>

<p>上記の<code>class DualBankConfig extends Config(new WithNBanks(2) ++ new DefaultConfig)</code>はどういう意味か？ <code>Config</code>と<code>Parameter</code>について見る。</p>
<h2 id="config">パラメータを渡すためのいくつかのテクニック: Config</h2>
<h3 id="config_1">Configの考え方：「<span style="color:blue">このモジュールに対してはこのパラメータを適用する</span>」の参照テーブル（マップ関数）を構築する</h3>
<h3 id="verilogpackage">⇔ Verilogの場合「<span style="color:red">パラメータをトップから降ろしていく/packageによる一元管理</span>」</h3>
<p><img alt="image-20201213142616432" src="../verilog_parameter_structure.PNG" /></p>
<div align="center">図. Verilogのパラメータを階層で降ろしていく（なんとなくの）イメージ</div>

<h4 id="chiselconfigkeykey">ChiselのConfigの場合：Keyに対する辞書を作って、モジュール内で必要なKeyからパラメータを取得</h4>
<pre><code class="sh">$ grep -h -R Key | grep Field
</code></pre>

<pre><code class="scala">case object APBDebugRegistersKey extends Field[Map[Int, Seq[RegField]]](Map())
case object DebugModuleKey extends Field[Option[DebugModuleParams]](Some(DebugModuleParams()))
case object DebugModuleHartSelKey extends Field(DebugModuleHartSelFuncs())
case object JtagDTMKey extends Field[JtagDTMConfig](new JtagDTMKeyDefault())
case object CLINTKey extends Field[Option[CLINTParams]](None)
...
case object SubsystemDriveAsyncClockGroupsKey extends Field[Option[ClockGroupDriverParameters]](Some(ClockGroupDriverParameters(1)))
case object AsyncClockGroupsKey extends Field[ClockGroupEphemeralNode](ClockGroupEphemeralNode()(ValName(&quot;async_clock_groups&quot;)))
case object BroadcastKey extends Field(BroadcastParams())
case object RocketTilesKey extends Field[Seq[RocketTileParams]](Nil)
case object RocketCrossingKey extends Field[Seq[RocketCrossingParams]](List(RocketCrossingParams()))
case object PeripheryMaskROMKey extends Field[Seq[MaskROMParams]](Nil)
...
case object PSDTestModeBroadcastKey extends Field(
</code></pre>

<p>辞書を作っているような感覚だと思ってもらえればよい：</p>
<table>
<thead>
<tr>
<th>検索元</th>
<th></th>
<th>検索先の型</th>
<th>補足</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>APBDebugRegistersKey</code></td>
<td>→</td>
<td><code>Map[Int, Seq[RegField]]</code></td>
<td></td>
</tr>
<tr>
<td><code>RocketTilesKey</code></td>
<td>→</td>
<td><code>Seq[RocketTileParams]]</code></td>
<td>何故<code>Seq</code>で囲まれているのか→<br />RocketTileはマルチコア構成だと複数配置されるので、それぞれTileのために<code>RocketTileParams</code>が複製されている</td>
</tr>
<tr>
<td><code>PeripheryMaskROMKey</code></td>
<td>→</td>
<td><code>Seq[MaskROMParams]</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>例えば、<code>RocketTileParams</code>は以下のような定義になっている。ちょうどSystem Verilogの<code>package</code>のようなものと解釈すれば良い？</p>
<pre><code class="scala">case class RocketCoreParams(
  bootFreqHz: BigInt = 0,
  useVM: Boolean = true,
  useUser: Boolean = false,
  useDebug: Boolean = true,
...
</code></pre>

<p>ではもう一度<code>DualCoreConfig</code>の定義に立ち戻って...</p>
<ul>
<li><code>DualCoreConfig</code>は<code>Config</code>クラスを継承したもの。<code>Config</code>クラスはViewに基づいた辞書テーブルの変換関数の集合と考えて良い。これらの辞書テーブルの変換関数の集合は、最終的に<code>Parameter</code>として集約されデザインに渡される。</li>
</ul>
<p><img alt="dualcoreconfig.PNG" src="../dualcoreconfig.PNG" /></p>
<p>各モジュールで、ここで定義したパラメータを呼び出して具体的な値を入手する。</p>
<ul>
<li><code>src/main/scala/rocket/RocketCore.scala</code></li>
</ul>
<pre><code class="scala">trait HasRocketCoreParameters extends HasCoreParameters {
  lazy val rocketParams: RocketCoreParams = tileParams.core.asInstanceOf[RocketCoreParams]

  val fastLoadWord = rocketParams.fastLoadWord
  val fastLoadByte = rocketParams.fastLoadByte

  val mulDivParams = rocketParams.mulDiv.getOrElse(MulDivParams()) // TODO ask andrew about this

  require(!fastLoadByte || fastLoadWord)
}
</code></pre>

<pre><code class="scala">@chiselName
class Rocket(tile: RocketTile)(implicit p: Parameters) extends CoreModule()(p)
    with HasRocketCoreParameters
    with HasCoreIO {

  val clock_en_reg = RegInit(true.B)
...
  // multiplier and divider
  val div = Module(new MulDiv(if (pipelinedMul) mulDivParams.copy(mulUnroll = 0) else mulDivParams, width = xLen))
  div.io.req.valid := ex_reg_valid &amp;&amp; ex_ctrl.div
  div.io.req.bits.dw := ex_ctrl.alu_dw
  div.io.req.bits.fn := ex_ctrl.alu_fn
...
</code></pre>

<ul>
<li><code>src/main/scala/rocket/Multiplier.scala</code></li>
</ul>
<pre><code class="scala">class MulDiv(cfg: MulDivParams, width: Int, nXpr: Int = 32) extends Module {
  private def minDivLatency = (cfg.divUnroll &gt; 0).option(if (cfg.divEarlyOut) 3 else 1 + w/cfg.divUnroll)
  private def minMulLatency = (cfg.mulUnroll &gt; 0).option(if (cfg.mulEarlyOut) 2 else w/cfg.mulUnroll)
  def minLatency: Int = (minDivLatency ++ minMulLatency).min

  val io = IO(new MultiplierIO(width, log2Up(nXpr)))
...
  val req = Reg(chiselTypeOf(io.req.bits))
  val count = Reg(UInt(log2Ceil(
    ((cfg.divUnroll != 0).option(w/cfg.divUnroll + 1).toSeq ++
     (cfg.mulUnroll != 0).option(mulw/cfg.mulUnroll)).reduce(_ max _)).W))

</code></pre>

<h3 id="here-site-up"><code>here()</code>, <code>site()</code>, <code>up()</code>などの使い方</h3>
<ul>
<li><code>Config</code>で使用しているパラメータを計算するにあたり、さらに別のパラメータの値を使用したい場合どうするか。Verilogでいう以下のようなことを実現したい場合を考える。</li>
</ul>
<pre><code class="verilog">localparam param1 = 100;
localparam param2 = param1 * 100;
</code></pre>

<p>これをChiselで実現しようしようとすると以下のようになるだろう。<code>BusWidthBytes</code>パラメータを使用してアドレスサイズの計算をしている。</p>
<pre><code class="scala">class Bus128BitConfig extends Config((site, here, up) =&gt; {
  case BusWidthBytes =&gt; 128 / 8
  // BusWidthBytes はcase classなので整数ではない
  case AddrSize =&gt; 0x100 * BusWidthBytes
})

class Bus64BitConfig extends Config((site, here, up) =&gt; {
  case BusWidthBytes =&gt; 64 / 8
  // BusWidthBytes はcase classなので整数ではない
  case AddrSize =&gt; 0x200 * BusWidthBytes
})

[error] /home/msyksphinz/work/riscv/chisel-development/minimal-diplomacy/src/main/scala/core_complex/Configs.scala:11:26: overloaded method value * with alternatives:
[error]   (x: Double)Double &lt;and&gt;
[error]   (x: Float)Float &lt;and&gt;
[error]   (x: Long)Long &lt;and&gt;
[error]   (x: Int)Int &lt;and&gt;
[error]   (x: Char)Int &lt;and&gt;
[error]   (x: Short)Int &lt;and&gt;
[error]   (x: Byte)Int
[error]  cannot be applied to (core_complex.BusWidthBytes.type)
[error]   case AddrSize =&gt; 0x100 * BusWidthBytes  // &lt;-- BusWidthBytes は数値じゃない！
[error]                          ^
</code></pre>

<p>ようするに<code>BusWidthBytes</code>自体がcase classなので、値として直接使用することができない。そこで、同じ<code>Config</code>内の値を参照するための<code>here()</code>などの情報を使用して辞書サーチをする。</p>
<pre><code class="scala">class Bus128BitConfig extends Config((site, here, up) =&gt; {
  case BusWidthBytes =&gt; 128 / 8
  case AddrSize =&gt; 0x100 * here(BusWidthBytes)
})

class Bus64BitConfig extends Config((site, here, up) =&gt; {
  case BusWidthBytes =&gt; 64 / 8
  case AddrSize =&gt; 0x200 * here(BusWidthBytes)
})
// Bus128BitConfigで構成したTLRAM, 12ビットのバス幅で構成される
module TLRAM(
  input         clock,
  input         reset,
  input         auto_in_a_valid,
  input  [2:0]  auto_in_a_bits_opcode,
  input  [11:0] auto_in_a_bits_address,
  input  [31:0] auto_in_a_bits_data,
  output        auto_in_d_valid,
  output [2:0]  auto_in_d_bits_opcode,
  output [31:0] auto_in_d_bits_data
);
</code></pre>

<p>一方で、<code>site()</code>を使用するとより上位のConfigを使用するようになる。例えば<code>Default2Config</code>では以下のように構成している。</p>
<ul>
<li><code>sites()</code>を使用するケース：<code>Bus128BitConfig</code>で<code>site()</code>を使用すると<code>BaseConfig</code>を参照する。つまり<code>AddrSize</code>は<code>0x100 * (256/8)</code>になるはずだ。</li>
</ul>
<pre><code class="scala">class Default2Config extends Config(
  new BaseConfig ++
  new Bus128BitConfig ++ new IfuNotConnectConfig
)
class BaseConfig extends Config((site, here, up) =&gt; {
  case BusWidthBytes =&gt; 256 / 8
})

class Bus128BitConfig extends Config((site, here, up) =&gt; {
  case BusWidthBytes =&gt; 128 / 8
  case AddrSize =&gt; 0x100 * here(BusWidthBytes)
})
// BaseConfigで構成したTLRAM, 13ビットのバス幅で構成される
module TLRAM(
  input          clock,
  input          reset,
  input          auto_in_a_valid,
  input  [2:0]   auto_in_a_bits_opcode,
  input  [12:0]  auto_in_a_bits_address,
  input  [255:0] auto_in_a_bits_data,
  output         auto_in_d_valid,
  output [2:0]   auto_in_d_bits_opcode,
  output [255:0] auto_in_d_bits_data
);
</code></pre>

<ul>
<li><code>up()</code>を使用するケース：以下では、<code>Adder()</code>と<code>Mul()</code>の2つのモジュールを定義している。<code>p(BitWidth)</code>で入出力ビット数を定義している。<code>Adder()</code>と<code>Mul()</code>のビット幅を全く別物で定義したい場合どうするかという問題を考える。</li>
</ul>
<pre><code class="scala">class Adder()(implicit p: Parameters) extends Module {
  val bitwidth = p(BitWidth)
  val io = IO(new Bundle{
    val a = Input(SInt(bitwidth.W))
    val b = Input(SInt(bitwidth.W))
    val c = Output(SInt(bitwidth.W))
  })

  io.c := io.a + io.b
}

class Mul()(implicit p: Parameters) extends Module {
  val bitwidth = p(BitWidth)
  val io = IO(new Bundle{
    val a = Input(SInt(bitwidth.W))
    val b = Input(SInt(bitwidth.W))
    val c = Output(SInt((bitwidth * 2).W))
  })

  io.c := io.a * io.b
}
</code></pre>

<p>この時、<code>Adder()</code>と<code>Mul()</code>のパラメータは以下のように定義している。<code>Adder()</code>は64ビット、<code>Mul()</code>は128ビットの入力ビット幅でインスタンス化するものとする。</p>
<pre><code class="scala">case object AdderBitWidth extends Field[Int]
case object MulBitWidth extends Field[Int]

class DefaultConfig() extends Config((site, here, up) =&gt; {
  case AdderBitWidth =&gt; 64
  case MulBitWidth =&gt; 128
})
</code></pre>

<p><code>Adder()</code>と<code>Mul()</code>をインスタンス時にそれぞれのパラメータをオーバライドするわけだが、<code>adder_param</code>と<code>mul_param</code>を新たに定義して渡すことになる。</p>
<pre><code class="scala">  val Adder_mod = Module(new Adder()(adder_params))
  Adder_mod.io.a := io.a
  Adder_mod.io.b := io.b
  io.Adder_c := Adder_mod.io.c

  val mul_mod = Module(new Mul()(mul_params))
  mul_mod.io.a := io.a
  mul_mod.io.b := io.b
  io.mul_c := mul_mod.io.c
</code></pre>

<p>ここで、<code>adder_params</code>は上記の<code>DefaultConfig</code>を引き継ぎつつ、<code>BitWidth</code>パラメータを継承前の<code>DefaultConfig</code>で使用しているパラメータで引き継ぐ。この時に<code>up()</code>を使用する。これにより、`</p>
<pre><code class="scala">  val adder_params = p.alter((site, here, up) =&gt; {
    case BitWidth =&gt; up(AdderBitWidth)
  })

  val mul_params = p.alter((site, here, up) =&gt; {
    case BitWidth =&gt; up(MulBitWidth)
  })
</code></pre>

<p><code>adder_params</code>の<code>BitWidth</code>は<code>DefaultConfig</code>の<code>AdderBitWidth</code>を引き継ぎ、<code>mul_params</code>の<code>BitWidth</code>は<code>DefaultConfig</code>の<code>MulBitWidth</code>を引き継ぐことになる。これにより、同じ<code>BitWidth</code>パラメータでも別々のパラメータを引き継ぐことが可能になる。</p>
<p>結果は以下の通り、<code>Adder</code>の入力ビット幅は<code>AddrBitWidth</code>を引き継いで64ビットとなり、<code>Mul</code>の入力ビット幅は<code>MulBitWidth</code>を引き継いで128ビットとなった。</p>
<pre><code class="verilog">module Adder(
  input  [63:0] io_a,
  input  [63:0] io_b,
  output [63:0] io_c
);
  assign io_c = $signed(io_a) + $signed(io_b); // @[up_example.scala 48:8]
endmodule
module Mul(
  input  [127:0] io_a,
  input  [127:0] io_b,
  output [255:0] io_c
);
  assign io_c = $signed(io_a) * $signed(io_b); // @[up_example.scala 59:8]
endmodule
</code></pre>

<h1 id="_1">まとめ</h1>
<ul>
<li>Chiselの活用ポイント → コア中ではなくネットワーク部。柔軟性が求められる部分。</li>
<li>Diplomacyを使って自作CPUのバスネットワークに接続する</li>
<li>Rocket-Chipのバス部分は大量のDiplomacyバス構成で構築されている</li>
<li><code>Config</code>/<code>Parameter</code>でより柔軟なパラメタライズを行う</li>
</ul>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../chisel_tilelink/" title="9. TileLinkとDiplomacyリファレンス" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                9. TileLinkとDiplomacyリファレンス
              </span>
            </div>
          </a>
        
        
          <a href="../memo/" title="Chisel v.s. Verilog" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Chisel v.s. Verilog
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.d9aa80ab.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
    
  </body>
</html>